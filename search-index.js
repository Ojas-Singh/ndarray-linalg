var searchIndex = JSON.parse('{\
"lax":{"doc":"Linear Algebra eXtension (LAX)ndarray-free safe Rust …","i":[[0,"error","lax","",null,null],[6,"Result","lax::error","",null,null],[4,"Error","","",null,null],[13,"LapackInvalidValue","","",0,null],[12,"return_code","lax::error::Error","",1,null],[13,"LapackComputationalFailure","lax::error","",0,null],[12,"return_code","lax::error::Error","",2,null],[13,"InvalidShape","lax::error","Strides of the array is not supported",0,null],[8,"AsLapackResult","","",null,null],[10,"as_lapack_result","","",3,[[],["result",6]]],[0,"layout","lax","Memory layout of matrices",null,null],[4,"MatrixLayout","lax::layout","",null,null],[13,"C","","",4,null],[12,"row","lax::layout::MatrixLayout","",5,null],[12,"lda","","",5,null],[13,"F","lax::layout","",4,null],[12,"col","lax::layout::MatrixLayout","",6,null],[12,"lda","","",6,null],[11,"size","lax::layout","",4,[[]]],[11,"resized","","",4,[[["i32",15]],["matrixlayout",4]]],[11,"lda","","",4,[[],["i32",15]]],[11,"len","","",4,[[],["i32",15]]],[11,"is_empty","","",4,[[],["bool",15]]],[11,"same_order","","",4,[[["matrixlayout",4]],["bool",15]]],[11,"toggle_order","","",4,[[]]],[11,"t","","Transpose without changing memory representation",4,[[]]],[5,"square_transpose","","In-place transpose of a square matrix by keeping F/C …",null,[[["matrixlayout",4]]]],[5,"transpose","","Out-place transpose for general matrix",null,[[["matrixlayout",4]],["matrixlayout",4]]],[8,"Cholesky_","lax","",null,null],[10,"cholesky","","Cholesky: wrapper of <code>*potrf</code>",7,[[["uplo",4],["matrixlayout",4]],["result",6]]],[10,"inv_cholesky","","Wrapper of <code>*potri</code>",7,[[["uplo",4],["matrixlayout",4]],["result",6]]],[10,"solve_cholesky","","Wrapper of <code>*potrs</code>",7,[[["uplo",4],["matrixlayout",4]],["result",6]]],[8,"Eig_","","Wraps <code>*geev</code> for general matrices",null,null],[10,"eig","","Calculate Right eigenvalue",8,[[["bool",15],["matrixlayout",4]],["result",6]]],[8,"Eigh_","","",null,null],[10,"eigh","","Wraps <code>*syev</code> for real and <code>*heev</code> for complex",9,[[["bool",15],["uplo",4],["matrixlayout",4]],[["result",6],["vec",3]]]],[10,"eigh_generalized","","Wraps <code>*syegv</code> for real and <code>*heegv</code> for complex",9,[[["bool",15],["uplo",4],["matrixlayout",4]],[["result",6],["vec",3]]]],[3,"LeastSquaresOutput","","Result of LeastSquares",null,null],[12,"singular_values","","singular values",10,null],[12,"rank","","The rank of the input matrix A",10,null],[8,"LeastSquaresSvdDivideConquer_","","Wraps <code>*gelsd</code>",null,null],[10,"least_squares","","",11,[[["matrixlayout",4]],[["result",6],["leastsquaresoutput",3]]]],[10,"least_squares_nrhs","","",11,[[["matrixlayout",4]],[["result",6],["leastsquaresoutput",3]]]],[8,"OperatorNorm_","","",null,null],[10,"opnorm","","",12,[[["normtype",4],["matrixlayout",4]]]],[8,"QR_","","",null,null],[10,"householder","","Execute Householder reflection as the first step of …",13,[[["matrixlayout",4]],[["vec",3],["result",6]]]],[10,"q","","Reconstruct Q-matrix from Householder-reflectors",13,[[["matrixlayout",4]],["result",6]]],[10,"qr","","Execute QR-decomposition at once",13,[[["matrixlayout",4]],[["vec",3],["result",6]]]],[8,"Rcond_","","",null,null],[10,"rcond","","Estimates the the reciprocal of the condition number of …",14,[[["matrixlayout",4]],["result",6]]],[8,"Solve_","","",null,null],[10,"lu","","Computes the LU factorization of a general <code>m x n</code> matrix <code>a</code> …",15,[[["matrixlayout",4]],[["result",6],["pivot",6]]]],[10,"inv","","",15,[[["pivot",6],["matrixlayout",4]],["result",6]]],[10,"solve","","",15,[[["transpose",4],["pivot",6],["matrixlayout",4]],["result",6]]],[8,"Solveh_","","",null,null],[10,"bk","","Bunch-Kaufman: wrapper of <code>*sytrf</code> and <code>*hetrf</code>",16,[[["uplo",4],["matrixlayout",4]],[["result",6],["pivot",6]]]],[10,"invh","","Wrapper of <code>*sytri</code> and <code>*hetri</code>",16,[[["pivot",6],["uplo",4],["matrixlayout",4]],["result",6]]],[10,"solveh","","Wrapper of <code>*sytrs</code> and <code>*hetrs</code>",16,[[["pivot",6],["uplo",4],["matrixlayout",4]],["result",6]]],[3,"SVDOutput","","Result of SVD",null,null],[12,"s","","diagonal values",17,null],[12,"u","","Unitary matrix for destination space",17,null],[12,"vt","","Unitary matrix for departure space",17,null],[8,"SVD_","","Wraps <code>*gesvd</code>",null,null],[10,"svd","","Calculate singular value decomposition $ A = U \\\\Sigma V^T …",18,[[["bool",15],["matrixlayout",4]],[["result",6],["svdoutput",3]]]],[4,"UVTFlag","","Specifies how many of the columns of <em>U</em> and rows of <em>V</em>ᵀ …",null,null],[13,"Full","","All <em>m</em> columns of <em>U</em> and all <em>n</em> rows of <em>V</em>ᵀ.",19,null],[13,"Some","","The first min(<em>m</em>,<em>n</em>) columns of <em>U</em> and the first min(<em>m</em>,<em>n</em>) …",19,null],[13,"None","","No columns of <em>U</em> or rows of <em>V</em>ᵀ.",19,null],[8,"SVDDC_","","",null,null],[10,"svddc","","",20,[[["uvtflag",4],["matrixlayout",4]],[["result",6],["svdoutput",3]]]],[4,"Diag","","",null,null],[13,"Unit","","",21,null],[13,"NonUnit","","",21,null],[8,"Triangular_","","Wraps <code>*trtri</code> and <code>*trtrs</code>",null,null],[10,"solve_triangular","","",22,[[["diag",4],["uplo",4],["matrixlayout",4]],["result",6]]],[3,"Tridiagonal","","Represents a tridiagonal matrix as 3 one-dimensional …",null,null],[12,"l","","layout of raw matrix",23,null],[12,"dl","","(n-1) sub-diagonal elements of matrix.",23,null],[12,"d","","(n) diagonal elements of matrix.",23,null],[12,"du","","(n-1) super-diagonal elements of matrix.",23,null],[3,"LUFactorizedTridiagonal","","Represents the LU factorization of a tridiagonal matrix <code>A</code> …",null,null],[12,"a","","A tridiagonal matrix which consists of",24,null],[12,"du2","","(n-2) elements of the second super-diagonal of U.",24,null],[12,"ipiv","","The pivot indices that define the permutation matrix <code>P</code>.",24,null],[8,"Tridiagonal_","","Wraps <code>*gttrf</code>, <code>*gtcon</code> and <code>*gttrs</code>",null,null],[10,"lu_tridiagonal","","Computes the LU factorization of a tridiagonal <code>m x n</code> …",25,[[["tridiagonal",3]],[["lufactorizedtridiagonal",3],["result",6]]]],[10,"rcond_tridiagonal","","",25,[[["lufactorizedtridiagonal",3]],["result",6]]],[10,"solve_tridiagonal","","",25,[[["lufactorizedtridiagonal",3],["transpose",4],["matrixlayout",4]],["result",6]]],[6,"Pivot","","",null,null],[8,"Lapack","","Trait for primitive types which implements LAPACK …",null,null],[4,"UPLO","","Upper/Lower specification for seveal usages",null,null],[13,"Upper","","",26,null],[13,"Lower","","",26,null],[11,"t","","",26,[[]]],[4,"Transpose","","",null,null],[13,"No","","",27,null],[13,"Transpose","","",27,null],[13,"Hermite","","",27,null],[4,"NormType","","",null,null],[13,"One","","",28,null],[13,"Infinity","","",28,null],[13,"Frobenius","","",28,null],[11,"transpose","","",28,[[]]],[11,"from","lax::error","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"vzip","","",0,[[]]],[11,"from","lax::layout","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"vzip","","",4,[[]]],[11,"from","lax","",10,[[]]],[11,"into","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"vzip","","",10,[[]]],[11,"from","","",17,[[]]],[11,"into","","",17,[[]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"vzip","","",17,[[]]],[11,"from","","",19,[[]]],[11,"into","","",19,[[]]],[11,"to_owned","","",19,[[]]],[11,"clone_into","","",19,[[]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"vzip","","",19,[[]]],[11,"from","","",21,[[]]],[11,"into","","",21,[[]]],[11,"to_owned","","",21,[[]]],[11,"clone_into","","",21,[[]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"vzip","","",21,[[]]],[11,"from","","",23,[[]]],[11,"into","","",23,[[]]],[11,"to_owned","","",23,[[]]],[11,"clone_into","","",23,[[]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"vzip","","",23,[[]]],[11,"from","","",24,[[]]],[11,"into","","",24,[[]]],[11,"to_owned","","",24,[[]]],[11,"clone_into","","",24,[[]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"try_into","","",24,[[],["result",4]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"vzip","","",24,[[]]],[11,"from","","",26,[[]]],[11,"into","","",26,[[]]],[11,"to_owned","","",26,[[]]],[11,"clone_into","","",26,[[]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"vzip","","",26,[[]]],[11,"from","","",27,[[]]],[11,"into","","",27,[[]]],[11,"to_owned","","",27,[[]]],[11,"clone_into","","",27,[[]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"vzip","","",27,[[]]],[11,"from","","",28,[[]]],[11,"into","","",28,[[]]],[11,"to_owned","","",28,[[]]],[11,"clone_into","","",28,[[]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"vzip","","",28,[[]]],[11,"clone","lax::layout","",4,[[],["matrixlayout",4]]],[11,"clone","lax","",19,[[],["uvtflag",4]]],[11,"clone","","",21,[[],["diag",4]]],[11,"clone","","",23,[[],["tridiagonal",3]]],[11,"clone","","",24,[[],["lufactorizedtridiagonal",3]]],[11,"clone","","",26,[[],["uplo",4]]],[11,"clone","","",27,[[],["transpose",4]]],[11,"clone","","",28,[[],["normtype",4]]],[11,"eq","lax::layout","",4,[[["matrixlayout",4]],["bool",15]]],[11,"ne","","",4,[[["matrixlayout",4]],["bool",15]]],[11,"eq","lax","",19,[[["uvtflag",4]],["bool",15]]],[11,"eq","","",23,[[["tridiagonal",3]],["bool",15]]],[11,"ne","","",23,[[["tridiagonal",3]],["bool",15]]],[11,"eq","","",24,[[["lufactorizedtridiagonal",3]],["bool",15]]],[11,"ne","","",24,[[["lufactorizedtridiagonal",3]],["bool",15]]],[11,"fmt","lax::error","",0,[[["formatter",3]],["result",6]]],[11,"fmt","lax::layout","",4,[[["formatter",3]],["result",6]]],[11,"fmt","lax","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",26,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","lax::error","",0,[[["formatter",3]],["result",6]]],[11,"index","lax","",23,[[]]],[11,"index","","",23,[[]]],[11,"index_mut","","",23,[[]]],[11,"index_mut","","",23,[[]]]],"p":[[4,"Error"],[13,"LapackInvalidValue"],[13,"LapackComputationalFailure"],[8,"AsLapackResult"],[4,"MatrixLayout"],[13,"C"],[13,"F"],[8,"Cholesky_"],[8,"Eig_"],[8,"Eigh_"],[3,"LeastSquaresOutput"],[8,"LeastSquaresSvdDivideConquer_"],[8,"OperatorNorm_"],[8,"QR_"],[8,"Rcond_"],[8,"Solve_"],[8,"Solveh_"],[3,"SVDOutput"],[8,"SVD_"],[4,"UVTFlag"],[8,"SVDDC_"],[4,"Diag"],[8,"Triangular_"],[3,"Tridiagonal"],[3,"LUFactorizedTridiagonal"],[8,"Tridiagonal_"],[4,"UPLO"],[4,"Transpose"],[4,"NormType"]]},\
"ndarray_linalg":{"doc":"The <code>ndarray-linalg</code> crate provides linear algebra …","i":[[0,"assert","ndarray_linalg","Assertions for array",null,null],[5,"rclose","ndarray_linalg::assert","check two values are close in terms of the relative …",null,[[["scalar",8]]]],[5,"aclose","","check two values are close in terms of the absolute …",null,[[["scalar",8]]]],[5,"close_max","","check two arrays are close in maximum norm",null,[[["arraybase",3],["arraybase",3]]]],[5,"close_l1","","check two arrays are close in L1 norm",null,[[["arraybase",3],["arraybase",3]]]],[5,"close_l2","","check two arrays are close in L2 norm",null,[[["arraybase",3],["arraybase",3]]]],[0,"cholesky","ndarray_linalg","Cholesky decomposition of Hermitian (or real symmetric) …",null,null],[4,"UPLO","ndarray_linalg::cholesky","Upper/Lower specification for seveal usages",null,null],[13,"Upper","","",0,null],[13,"Lower","","",0,null],[3,"CholeskyFactorized","","Cholesky decomposition of Hermitian (or real symmetric) …",null,null],[12,"factor","","<code>L</code> from the decomposition <code>A = L * L^H</code> or <code>U</code> from the …",1,null],[12,"uplo","","If this is <code>UPLO::Lower</code>, then <code>self.factor</code> is <code>L</code>. If this is …",1,null],[11,"into_lower","","Returns <code>L</code> from the Cholesky decomposition <code>A = L * L^H</code>.",1,[[],[["arraybase",3],["ix2",6]]]],[11,"into_upper","","Returns <code>U</code> from the Cholesky decomposition <code>A = U^H * U</code>.",1,[[],[["arraybase",3],["ix2",6]]]],[8,"Cholesky","","Cholesky decomposition of Hermitian (or real symmetric) …",null,null],[16,"Output","","",2,null],[10,"cholesky","","Computes the Cholesky decomposition of the Hermitian (or …",2,[[["uplo",4]],["result",6]]],[8,"CholeskyInto","","Cholesky decomposition of Hermitian (or real symmetric) …",null,null],[16,"Output","","",3,null],[10,"cholesky_into","","Computes the Cholesky decomposition of the Hermitian (or …",3,[[["uplo",4]],["result",6]]],[8,"CholeskyInplace","","Cholesky decomposition of Hermitian (or real symmetric) …",null,null],[10,"cholesky_inplace","","Computes the Cholesky decomposition of the Hermitian (or …",4,[[["uplo",4]],["result",6]]],[8,"FactorizeC","","Cholesky decomposition of Hermitian (or real symmetric) …",null,null],[10,"factorizec","","Computes the Cholesky decomposition of the Hermitian (or …",5,[[["uplo",4]],[["choleskyfactorized",3],["result",6]]]],[8,"FactorizeCInto","","Cholesky decomposition of Hermitian (or real symmetric) …",null,null],[10,"factorizec_into","","Computes the Cholesky decomposition of the Hermitian (or …",6,[[["uplo",4]],[["choleskyfactorized",3],["result",6]]]],[8,"SolveC","","Solve systems of linear equations with Hermitian (or real …",null,null],[11,"solvec","","Solves a system of linear equations <code>A * x = b</code> with …",7,[[["arraybase",3]],[["result",6],["array1",6]]]],[11,"solvec_into","","Solves a system of linear equations <code>A * x = b</code> with …",7,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[10,"solvec_inplace","","Solves a system of linear equations <code>A * x = b</code> with …",7,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[8,"InverseC","","Inverse of Hermitian (or real symmetric) positive …",null,null],[16,"Output","","",8,null],[10,"invc","","Computes the inverse of the Hermitian (or real symmetric) …",8,[[],["result",6]]],[8,"InverseCInto","","Inverse of Hermitian (or real symmetric) positive …",null,null],[16,"Output","","",9,null],[10,"invc_into","","Computes the inverse of the Hermitian (or real symmetric) …",9,[[],["result",6]]],[8,"DeterminantC","","Determinant of Hermitian (or real symmetric) positive …",null,null],[16,"Output","","",10,null],[10,"detc","","Computes the determinant of the Hermitian (or real …",10,[[]]],[10,"ln_detc","","Computes the natural log of the determinant of the …",10,[[]]],[8,"DeterminantCInto","","Determinant of Hermitian (or real symmetric) positive …",null,null],[16,"Output","","",11,null],[10,"detc_into","","Computes the determinant of the Hermitian (or real …",11,[[]]],[10,"ln_detc_into","","Computes the natural log of the determinant of the …",11,[[]]],[0,"convert","ndarray_linalg","utilities for convert array",null,null],[5,"into_col","ndarray_linalg::convert","",null,[[["arraybase",3],["ix1",6]],[["arraybase",3],["ix2",6]]]],[5,"into_row","","",null,[[["arraybase",3],["ix1",6]],[["arraybase",3],["ix2",6]]]],[5,"flatten","","",null,[[["arraybase",3],["ix2",6]],[["arraybase",3],["ix1",6]]]],[5,"into_matrix","","",null,[[["matrixlayout",4],["vec",3]],[["result",6],["arraybase",3]]]],[5,"replicate","","",null,[[["arraybase",3]],["arraybase",3]]],[5,"transpose_data","","",null,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[5,"generalize","","",null,[[["array",6]],["arraybase",3]]],[0,"diagonal","ndarray_linalg","Vector as a Diagonal matrix",null,null],[3,"Diagonal","ndarray_linalg::diagonal","Vector as a Diagonal matrix",null,null],[8,"IntoDiagonal","","",null,null],[10,"into_diagonal","","",12,[[],["diagonal",3]]],[8,"AsDiagonal","","",null,null],[10,"as_diagonal","","",13,[[],[["diagonal",3],["viewrepr",3]]]],[0,"eig","ndarray_linalg","Eigenvalue decomposition for non-symmetric square matrices",null,null],[8,"Eig","ndarray_linalg::eig","Eigenvalue decomposition of general matrix reference",null,null],[16,"EigVal","","EigVec is the right eivenvector",14,null],[16,"EigVec","","",14,null],[10,"eig","","Calculate eigenvalues with the right eigenvector",14,[[],["result",6]]],[8,"EigVals","","Calculate eigenvalues without eigenvectors",null,null],[16,"EigVal","","",15,null],[10,"eigvals","","",15,[[],["result",6]]],[0,"eigh","ndarray_linalg","Eigenvalue decomposition for Hermite matrices",null,null],[8,"Eigh","ndarray_linalg::eigh","Eigenvalue decomposition of Hermite matrix reference",null,null],[16,"EigVal","","",16,null],[16,"EigVec","","",16,null],[10,"eigh","","",16,[[["uplo",4]],["result",6]]],[8,"EighInplace","","Eigenvalue decomposition of mutable reference of Hermite …",null,null],[16,"EigVal","","",17,null],[10,"eigh_inplace","","",17,[[["uplo",4]],["result",6]]],[8,"EighInto","","Eigenvalue decomposition of Hermite matrix",null,null],[16,"EigVal","","",18,null],[10,"eigh_into","","",18,[[["uplo",4]],["result",6]]],[8,"EigValsh","","Calculate eigenvalues without eigenvectors",null,null],[16,"EigVal","","",19,null],[10,"eigvalsh","","",19,[[["uplo",4]],["result",6]]],[8,"EigValshInto","","Calculate eigenvalues without eigenvectors",null,null],[16,"EigVal","","",20,null],[10,"eigvalsh_into","","",20,[[["uplo",4]],["result",6]]],[8,"EigValshInplace","","Calculate eigenvalues without eigenvectors",null,null],[16,"EigVal","","",21,null],[10,"eigvalsh_inplace","","",21,[[["uplo",4]],["result",6]]],[8,"SymmetricSqrt","","Calculate symmetric square-root matrix using <code>eigh</code>",null,null],[16,"Output","","",22,null],[10,"ssqrt","","",22,[[["uplo",4]],["result",6]]],[8,"SymmetricSqrtInto","","Calculate symmetric square-root matrix using <code>eigh</code>",null,null],[16,"Output","","",23,null],[10,"ssqrt_into","","",23,[[["uplo",4]],["result",6]]],[0,"error","ndarray_linalg","Define Errors",null,null],[6,"Result","ndarray_linalg::error","",null,null],[4,"LinalgError","","Master Error type of this crate",null,null],[13,"NotSquare","","Matrix is not square",24,null],[12,"rows","ndarray_linalg::error::LinalgError","",25,null],[12,"cols","","",25,null],[13,"Lapack","ndarray_linalg::error","LAPACK subroutine returns non-zero code",24,null],[13,"InvalidStride","","Strides of the array is not supported",24,null],[12,"s0","ndarray_linalg::error::LinalgError","",26,null],[12,"s1","","",26,null],[13,"MemoryNotCont","ndarray_linalg::error","Memory is not aligned continously",24,null],[13,"NotStandardShape","","Obj cannot be made from a (rows, cols) matrix",24,null],[12,"obj","ndarray_linalg::error::LinalgError","",27,null],[12,"rows","","",27,null],[12,"cols","","",27,null],[13,"Shape","ndarray_linalg::error","Strides of the array is not supported",24,null],[0,"generate","ndarray_linalg","Generator functions for matrices",null,null],[5,"conjugate","ndarray_linalg::generate","Hermite conjugate matrix",null,[[["arraybase",3]],[["arraybase",3],["ix2",6]]]],[5,"random","","Generate random array",null,[[],["arraybase",3]]],[5,"random_unitary","","Generate random unitary matrix using QR decomposition",null,[[["usize",15]],["array2",6]]],[5,"random_regular","","Generate random regular matrix",null,[[["usize",15]],["array2",6]]],[5,"random_hermite","","Random Hermite matrix",null,[[["usize",15]],[["arraybase",3],["ix2",6]]]],[5,"random_hpd","","Random Hermite Positive-definite matrix",null,[[["usize",15]],[["arraybase",3],["ix2",6]]]],[5,"from_diag","","construct matrix from diag",null,[[],["array2",6]]],[5,"hstack","","stack vectors into matrix horizontally",null,[[],[["result",6],["array",6]]]],[5,"vstack","","stack vectors into matrix vertically",null,[[],[["result",6],["array",6]]]],[0,"inner","ndarray_linalg","",null,null],[8,"InnerProduct","ndarray_linalg::inner","Inner Product",null,null],[16,"Elem","","",28,null],[10,"inner","","Inner product `(self.conjugate, rhs)",28,[[["arraybase",3]]]],[0,"krylov","ndarray_linalg","Krylov subspace methods",null,null],[0,"arnoldi","ndarray_linalg::krylov","Arnoldi iteration",null,null],[3,"Arnoldi","ndarray_linalg::krylov::arnoldi","Execute Arnoldi iteration as Rust iterator",null,null],[11,"new","","Create an Arnoldi iterator from any linear operator <code>a</code>",29,[[["arraybase",3],["ix1",6]]]],[11,"dim","","Dimension of Krylov subspace",29,[[],["usize",15]]],[11,"complete","","Iterate until convergent",29,[[]]],[5,"arnoldi_householder","","Utility to execute Arnoldi iteration with Householder …",null,[[["arraybase",3],["ix1",6]]]],[5,"arnoldi_mgs","","Utility to execute Arnoldi iteration with modified …",null,[[["arraybase",3],["ix1",6]]]],[0,"householder","ndarray_linalg::krylov","Householder reflection",null,null],[5,"calc_reflector","ndarray_linalg::krylov::householder","Calc a reflactor <code>w</code> from a vector <code>x</code>",null,[[["arraybase",3]]]],[5,"reflect","","Take a reflection <code>P = I - 2ww^T</code>",null,[[["arraybase",3],["arraybase",3]]]],[3,"Householder","","Iterative orthogonalizer using Householder reflection",null,null],[11,"new","","Create a new orthogonalizer",30,[[["usize",15]]]],[11,"forward_reflection","","Take forward reflection <code>P = P_l ... P_1</code>",30,[[["arraybase",3]]]],[11,"backward_reflection","","Take backward reflection <code>P = P_1 ... P_l</code>",30,[[["arraybase",3]]]],[5,"householder","","Online QR decomposition using Householder reflection",null,[[["usize",15],["strategy",4]]]],[0,"mgs","ndarray_linalg::krylov","Modified Gram-Schmit orthogonalizer",null,null],[3,"MGS","ndarray_linalg::krylov::mgs","Iterative orthogonalizer using modified Gram-Schmit …",null,null],[11,"new","","Create an empty orthogonalizer",31,[[["usize",15]]]],[5,"mgs","","Online QR decomposition using modified Gram-Schmit …",null,[[["usize",15],["strategy",4]]]],[6,"Q","ndarray_linalg::krylov","Q-matrix",null,null],[6,"R","","R-matrix",null,null],[6,"H","","H-matrix",null,null],[6,"Coefficients","","Array type for coefficients to the current basis",null,null],[8,"Orthogonalizer","","Trait for creating orthogonal basis from iterator of …",null,null],[16,"Elem","","",32,null],[10,"dim","","Dimension of input array",32,[[],["usize",15]]],[10,"len","","Number of cached basis",32,[[],["usize",15]]],[11,"is_full","","check if the basis spans entire space",32,[[],["bool",15]]],[11,"is_empty","","",32,[[],["bool",15]]],[10,"tolerance","","",32,[[]]],[10,"decompose","","Decompose given vector into the span of current basis and …",32,[[["arraybase",3]],["coefficients",6]]],[10,"coeff","","Calculate the coefficient to the current basis basis",32,[[["arraybase",3],["ix1",6]],["coefficients",6]]],[10,"append","","Add new vector if the residual is larger than relative …",32,[[["arraybase",3],["ix1",6]],["appendresult",4]]],[10,"div_append","","Add new vector if the residual is larger than relative …",32,[[["arraybase",3]],["appendresult",4]]],[10,"get_q","","Get Q-matrix of generated basis",32,[[],["q",6]]],[4,"AppendResult","","",null,null],[13,"Added","","",33,null],[13,"Dependent","","",33,null],[11,"into_coeff","","",33,[[],["coefficients",6]]],[11,"is_dependent","","",33,[[],["bool",15]]],[11,"coeff","","",33,[[],["coefficients",6]]],[11,"residual_norm","","",33,[[]]],[4,"Strategy","","Strategy for linearly dependent vectors appearing in …",null,null],[13,"Terminate","","Terminate iteration if dependent vector comes",34,null],[13,"Skip","","Skip dependent vector",34,null],[13,"Full","","Orthogonalize dependent vector without adding to Q, i.e. …",34,null],[5,"qr","","Online QR decomposition using arbitrary orthogonalizer",null,[[["strategy",4]]]],[0,"layout","ndarray_linalg","Convert ndarray into LAPACK-compatible matrix format",null,null],[4,"MatrixLayout","ndarray_linalg::layout","",null,null],[13,"C","","",35,null],[12,"row","ndarray_linalg::layout::MatrixLayout","",36,null],[12,"lda","","",36,null],[13,"F","ndarray_linalg::layout","",35,null],[12,"col","ndarray_linalg::layout::MatrixLayout","",37,null],[12,"lda","","",37,null],[8,"AllocatedArray","ndarray_linalg::layout","",null,null],[16,"Elem","","",38,null],[10,"layout","","",38,[[],[["matrixlayout",4],["result",6]]]],[10,"square_layout","","",38,[[],[["matrixlayout",4],["result",6]]]],[10,"ensure_square","","Returns Ok iff the matrix is square (without computing …",38,[[],["result",6]]],[10,"as_allocated","","",38,[[],["result",6]]],[8,"AllocatedArrayMut","","",null,null],[10,"as_allocated_mut","","",39,[[],["result",6]]],[0,"least_squares","ndarray_linalg","Least SquaresCompute a least-squares solution to the …",null,null],[3,"LeastSquaresResult","ndarray_linalg::least_squares","Result of a LeastSquares computation",null,null],[12,"singular_values","","The singular values of the matrix A in <code>Ax = b</code>",40,null],[12,"solution","","The solution vector or matrix <code>x</code> which is the best …",40,null],[12,"rank","","The rank of the matrix A in <code>Ax = b</code>",40,null],[12,"residual_sum_of_squares","","If n < m and rank(A) == n, the sum of squares If b is a …",40,null],[8,"LeastSquaresSvd","","Solve least squares for immutable references",null,null],[10,"least_squares","","Solve a least squares problem of the form <code>Ax = rhs</code> by …",41,[[["arraybase",3]],[["result",6],["leastsquaresresult",3]]]],[8,"LeastSquaresSvdInto","","Solve least squares for owned matrices",null,null],[10,"least_squares_into","","Solve a least squares problem of the form <code>Ax = rhs</code> by …",42,[[["arraybase",3]],[["result",6],["leastsquaresresult",3]]]],[8,"LeastSquaresSvdInPlace","","Solve least squares for mutable references, overwriting …",null,null],[10,"least_squares_in_place","","Solve a least squares problem of the form <code>Ax = rhs</code> by …",43,[[["arraybase",3]],[["result",6],["leastsquaresresult",3]]]],[0,"lobpcg","ndarray_linalg","",null,null],[3,"TruncatedEig","ndarray_linalg::lobpcg","Truncated eigenproblem solver",null,null],[12,"constraints","","",44,null],[5,"lobpcg","","Eigenvalue solver for large symmetric positive definite …",null,[[["fn",8],["option",4],["f32",15],["scalar",8],["usize",15],["order",4],["lapack",8],["partialord",8],["array2",6],["default",8],["fn",8],["float",8],["scalaroperand",8]],[["lapack",8],["partialord",8],["lobpcgresult",4],["scalar",8],["default",8],["float",8],["scalaroperand",8]]]],[4,"LobpcgResult","","The result of the eigensolver",null,null],[13,"Ok","","",45,null],[13,"Err","","",45,null],[13,"NoResult","","",45,null],[4,"TruncatedOrder","","Find largest or smallest eigenvalues",null,null],[13,"Largest","","",46,null],[13,"Smallest","","",46,null],[3,"TruncatedSvd","","Truncated singular value decomposition",null,null],[0,"norm","ndarray_linalg","Norm of vectors",null,null],[8,"Norm","ndarray_linalg::norm","Define norm as a metric linear space (not as a matrix)",null,null],[16,"Output","","",47,null],[11,"norm","","rename of <code>norm_l2</code>",47,[[]]],[10,"norm_l1","","L-1 norm",47,[[]]],[10,"norm_l2","","L-2 norm",47,[[]]],[10,"norm_max","","maximum norm",47,[[]]],[4,"NormalizeAxis","","",null,null],[13,"Row","","",48,null],[13,"Column","","",48,null],[5,"normalize","","normalize in L2 norm",null,[[["normalizeaxis",4],["arraybase",3],["ix2",6]]]],[0,"operator","ndarray_linalg","Linear operator algebra",null,null],[8,"LinearOperator","ndarray_linalg::operator","Abstracted linear operator as an action to vector (…",null,null],[16,"Elem","","",49,null],[11,"apply","","Apply operator out-place",49,[[["arraybase",3]],["array1",6]]],[11,"apply_mut","","Apply operator in-place",49,[[["arraybase",3]]]],[11,"apply_into","","Apply operator with move",49,[[["arraybase",3],["ix1",6]],[["arraybase",3],["ix1",6]]]],[11,"apply2","","Apply operator to matrix out-place",49,[[["arraybase",3]],["array2",6]]],[11,"apply2_mut","","Apply operator to matrix in-place",49,[[["arraybase",3]]]],[11,"apply2_into","","Apply operator to matrix with move",49,[[["arraybase",3],["ix2",6]],[["arraybase",3],["ix2",6]]]],[0,"opnorm","ndarray_linalg","Operator norm",null,null],[4,"NormType","ndarray_linalg::opnorm","",null,null],[13,"One","","",50,null],[13,"Infinity","","",50,null],[13,"Frobenius","","",50,null],[8,"OperationNorm","","Operator norm using <code>*lange</code> LAPACK routines",null,null],[16,"Output","","the value of norm",51,null],[10,"opnorm","","",51,[[["normtype",4]],["result",6]]],[11,"opnorm_one","","the one norm of a matrix (maximum column sum)",51,[[],["result",6]]],[11,"opnorm_inf","","the infinity norm of a matrix (maximum row sum)",51,[[],["result",6]]],[11,"opnorm_fro","","the Frobenius norm of a matrix (square root of sum of …",51,[[],["result",6]]],[0,"qr","ndarray_linalg","QR decomposition",null,null],[4,"UPLO","ndarray_linalg::qr","Upper/Lower specification for seveal usages",null,null],[13,"Upper","","",0,null],[13,"Lower","","",0,null],[8,"QR","","QR decomposition for matrix reference",null,null],[16,"Q","","",52,null],[16,"R","","",52,null],[10,"qr","","",52,[[],["result",6]]],[8,"QRInto","","QR decomposition",null,null],[16,"Q","","",53,null],[16,"R","","",53,null],[10,"qr_into","","",53,[[],["result",6]]],[8,"QRSquare","","QR decomposition for square matrix reference",null,null],[16,"Q","","",54,null],[16,"R","","",54,null],[10,"qr_square","","",54,[[],["result",6]]],[8,"QRSquareInto","","QR decomposition for square matrix",null,null],[16,"R","","",55,null],[10,"qr_square_into","","",55,[[],["result",6]]],[8,"QRSquareInplace","","QR decomposition for mutable reference of square matrix",null,null],[16,"R","","",56,null],[10,"qr_square_inplace","","",56,[[],["result",6]]],[0,"solve","ndarray_linalg","Solve systems of linear equations and invert matrices",null,null],[6,"Pivot","ndarray_linalg::solve","",null,null],[4,"Transpose","","",null,null],[13,"No","","",57,null],[13,"Transpose","","",57,null],[13,"Hermite","","",57,null],[8,"Solve","","An interface for solving systems of linear equations.",null,null],[11,"solve","","Solves a system of linear equations <code>A * x = b</code> where <code>A</code> is …",58,[[["arraybase",3]],[["result",6],["array1",6]]]],[11,"solve_into","","Solves a system of linear equations <code>A * x = b</code> where <code>A</code> is …",58,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[10,"solve_inplace","","Solves a system of linear equations <code>A * x = b</code> where <code>A</code> is …",58,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[11,"solve_t","","Solves a system of linear equations <code>A^T * x = b</code> where <code>A</code> …",58,[[["arraybase",3]],[["result",6],["array1",6]]]],[11,"solve_t_into","","Solves a system of linear equations <code>A^T * x = b</code> where <code>A</code> …",58,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[10,"solve_t_inplace","","Solves a system of linear equations <code>A^T * x = b</code> where <code>A</code> …",58,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[11,"solve_h","","Solves a system of linear equations <code>A^H * x = b</code> where <code>A</code> …",58,[[["arraybase",3]],[["result",6],["array1",6]]]],[11,"solve_h_into","","Solves a system of linear equations <code>A^H * x = b</code> where <code>A</code> …",58,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[10,"solve_h_inplace","","Solves a system of linear equations <code>A^H * x = b</code> where <code>A</code> …",58,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[3,"LUFactorized","","Represents the LU factorization of a matrix <code>A</code> as <code>A = P*L*U</code>…",null,null],[12,"a","","The factors <code>L</code> and <code>U</code>; the unit diagonal elements of <code>L</code> are …",59,null],[12,"ipiv","","The pivot indices that define the permutation matrix <code>P</code>.",59,null],[8,"Factorize","","An interface for computing LU factorizations of matrix …",null,null],[10,"factorize","","Computes the LU factorization <code>A = P*L*U</code>, where <code>P</code> is a …",60,[[],[["result",6],["lufactorized",3]]]],[8,"FactorizeInto","","An interface for computing LU factorizations of matrices.",null,null],[10,"factorize_into","","Computes the LU factorization <code>A = P*L*U</code>, where <code>P</code> is a …",61,[[],[["result",6],["lufactorized",3]]]],[8,"Inverse","","An interface for inverting matrix refs.",null,null],[16,"Output","","",62,null],[10,"inv","","Computes the inverse of the matrix.",62,[[],["result",6]]],[8,"InverseInto","","An interface for inverting matrices.",null,null],[16,"Output","","",63,null],[10,"inv_into","","Computes the inverse of the matrix.",63,[[],["result",6]]],[8,"Determinant","","An interface for calculating determinants of matrix refs.",null,null],[11,"det","","Computes the determinant of the matrix.",64,[[],["result",6]]],[10,"sln_det","","Computes the <code>(sign, natural_log)</code> of the determinant of …",64,[[],["result",6]]],[8,"DeterminantInto","","An interface for calculating determinants of matrices.",null,null],[11,"det_into","","Computes the determinant of the matrix.",65,[[],["result",6]]],[10,"sln_det_into","","Computes the <code>(sign, natural_log)</code> of the determinant of …",65,[[],["result",6]]],[8,"ReciprocalConditionNum","","An interface for <em>estimating</em> the reciprocal condition …",null,null],[10,"rcond","","<em>Estimates</em> the reciprocal of the condition number of the …",66,[[],["result",6]]],[8,"ReciprocalConditionNumInto","","An interface for <em>estimating</em> the reciprocal condition …",null,null],[10,"rcond_into","","<em>Estimates</em> the reciprocal of the condition number of the …",67,[[],["result",6]]],[0,"solveh","ndarray_linalg","Solve Hermitian (or real symmetric) linear problems and …",null,null],[6,"Pivot","ndarray_linalg::solveh","",null,null],[4,"UPLO","","Upper/Lower specification for seveal usages",null,null],[13,"Upper","","",0,null],[13,"Lower","","",0,null],[8,"SolveH","","An interface for solving systems of Hermitian (or real …",null,null],[11,"solveh","","Solves a system of linear equations <code>A * x = b</code> with …",68,[[["arraybase",3]],[["result",6],["array1",6]]]],[11,"solveh_into","","Solves a system of linear equations <code>A * x = b</code> with …",68,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[10,"solveh_inplace","","Solves a system of linear equations <code>A * x = b</code> with …",68,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[3,"BKFactorized","","Represents the Bunch–Kaufman factorization of a …",null,null],[12,"a","","",69,null],[12,"ipiv","","",69,null],[8,"FactorizeH","","An interface for computing the Bunch–Kaufman …",null,null],[10,"factorizeh","","Computes the Bunch–Kaufman factorization of a Hermitian …",70,[[],[["result",6],["bkfactorized",3]]]],[8,"FactorizeHInto","","An interface for computing the Bunch–Kaufman …",null,null],[10,"factorizeh_into","","Computes the Bunch–Kaufman factorization of a Hermitian …",71,[[],[["result",6],["bkfactorized",3]]]],[8,"InverseH","","An interface for inverting Hermitian (or real symmetric) …",null,null],[16,"Output","","",72,null],[10,"invh","","Computes the inverse of the Hermitian (or real symmetric) …",72,[[],["result",6]]],[8,"InverseHInto","","An interface for inverting Hermitian (or real symmetric) …",null,null],[16,"Output","","",73,null],[10,"invh_into","","Computes the inverse of the Hermitian (or real symmetric) …",73,[[],["result",6]]],[8,"DeterminantH","","An interface for calculating determinants of Hermitian …",null,null],[16,"Elem","","The element type of the matrix.",74,null],[10,"deth","","Computes the determinant of the Hermitian (or real …",74,[[],["result",6]]],[10,"sln_deth","","Computes the <code>(sign, natural_log)</code> of the determinant of …",74,[[],["result",6]]],[8,"DeterminantHInto","","An interface for calculating determinants of Hermitian …",null,null],[16,"Elem","","The element type of the matrix.",75,null],[10,"deth_into","","Computes the determinant of the Hermitian (or real …",75,[[],["result",6]]],[10,"sln_deth_into","","Computes the <code>(sign, natural_log)</code> of the determinant of …",75,[[],["result",6]]],[11,"deth","","Computes the determinant of the factorized Hermitian (or …",69,[[]]],[11,"sln_deth","","Computes the <code>(sign, natural_log)</code> of the determinant of …",69,[[]]],[11,"deth_into","","Computes the determinant of the factorized Hermitian (or …",69,[[]]],[11,"sln_deth_into","","Computes the <code>(sign, natural_log)</code> of the determinant of …",69,[[]]],[0,"svd","ndarray_linalg","Singular-value decomposition (SVD)",null,null],[8,"SVD","ndarray_linalg::svd","singular-value decomposition of matrix reference",null,null],[16,"U","","",76,null],[16,"VT","","",76,null],[16,"Sigma","","",76,null],[10,"svd","","",76,[[["bool",15]],["result",6]]],[8,"SVDInto","","singular-value decomposition",null,null],[16,"U","","",77,null],[16,"VT","","",77,null],[16,"Sigma","","",77,null],[10,"svd_into","","",77,[[["bool",15]],["result",6]]],[8,"SVDInplace","","singular-value decomposition for mutable reference of …",null,null],[16,"U","","",78,null],[16,"VT","","",78,null],[16,"Sigma","","",78,null],[10,"svd_inplace","","",78,[[["bool",15]],["result",6]]],[0,"svddc","ndarray_linalg","Singular-value decomposition (SVD) by divide-and-conquer …",null,null],[4,"UVTFlag","ndarray_linalg::svddc","Specifies how many of the columns of <em>U</em> and rows of <em>V</em>ᵀ …",null,null],[13,"Full","","All <em>m</em> columns of <em>U</em> and all <em>n</em> rows of <em>V</em>ᵀ.",79,null],[13,"Some","","The first min(<em>m</em>,<em>n</em>) columns of <em>U</em> and the first min(<em>m</em>,<em>n</em>) …",79,null],[13,"None","","No columns of <em>U</em> or rows of <em>V</em>ᵀ.",79,null],[8,"SVDDC","","Singular-value decomposition of matrix (copying) by …",null,null],[16,"U","","",80,null],[16,"VT","","",80,null],[16,"Sigma","","",80,null],[10,"svddc","","",80,[[["uvtflag",4]],["result",6]]],[8,"SVDDCInto","","Singular-value decomposition of matrix by …",null,null],[16,"U","","",81,null],[16,"VT","","",81,null],[16,"Sigma","","",81,null],[10,"svddc_into","","",81,[[["uvtflag",4]],["result",6]]],[8,"SVDDCInplace","","Singular-value decomposition of matrix reference by …",null,null],[16,"U","","",82,null],[16,"VT","","",82,null],[16,"Sigma","","",82,null],[10,"svddc_inplace","","",82,[[["uvtflag",4]],["result",6]]],[0,"trace","ndarray_linalg","Trace calculation",null,null],[8,"Trace","ndarray_linalg::trace","",null,null],[16,"Output","","",83,null],[10,"trace","","",83,[[],["result",6]]],[0,"triangular","ndarray_linalg","Methods for triangular matrices",null,null],[4,"Diag","ndarray_linalg::triangular","",null,null],[13,"Unit","","",84,null],[13,"NonUnit","","",84,null],[8,"SolveTriangular","","solve a triangular system with upper triangular matrix",null,null],[10,"solve_triangular","","",85,[[["diag",4],["uplo",4],["arraybase",3]],[["result",6],["array",6]]]],[8,"SolveTriangularInto","","solve a triangular system with upper triangular matrix",null,null],[10,"solve_triangular_into","","",86,[[["diag",4],["uplo",4],["arraybase",3]],[["result",6],["arraybase",3]]]],[8,"SolveTriangularInplace","","solve a triangular system with upper triangular matrix",null,null],[10,"solve_triangular_inplace","","",87,[[["diag",4],["uplo",4],["arraybase",3]],[["arraybase",3],["result",6]]]],[8,"IntoTriangular","","",null,null],[10,"into_triangular","","",88,[[["uplo",4]]]],[0,"tridiagonal","ndarray_linalg","Vectors as a Tridiagonal matrix & Methods for tridiagonal …",null,null],[3,"LUFactorizedTridiagonal","ndarray_linalg::tridiagonal","Represents the LU factorization of a tridiagonal matrix <code>A</code> …",null,null],[12,"a","","A tridiagonal matrix which consists of",89,null],[12,"du2","","(n-2) elements of the second super-diagonal of U.",89,null],[12,"ipiv","","The pivot indices that define the permutation matrix <code>P</code>.",89,null],[3,"Tridiagonal","","Represents a tridiagonal matrix as 3 one-dimensional …",null,null],[12,"l","","layout of raw matrix",90,null],[12,"dl","","(n-1) sub-diagonal elements of matrix.",90,null],[12,"d","","(n) diagonal elements of matrix.",90,null],[12,"du","","(n-1) super-diagonal elements of matrix.",90,null],[8,"ExtractTridiagonal","","An interface for making a Tridiagonal struct.",null,null],[10,"extract_tridiagonal","","Extract tridiagonal elements and layout of the raw matrix.",91,[[],[["result",6],["tridiagonal",3]]]],[8,"SolveTridiagonal","","",null,null],[10,"solve_tridiagonal","","Solves a system of linear equations <code>A * x = b</code> with …",92,[[["arraybase",3]],[["result",6],["array",6]]]],[10,"solve_tridiagonal_into","","Solves a system of linear equations <code>A * x = b</code> with …",92,[[["datamut",8],["arraybase",3]],[["result",6],["arraybase",3]]]],[10,"solve_t_tridiagonal","","Solves a system of linear equations <code>A^T * x = b</code> with …",92,[[["arraybase",3]],[["result",6],["array",6]]]],[10,"solve_t_tridiagonal_into","","Solves a system of linear equations <code>A^T * x = b</code> with …",92,[[["datamut",8],["arraybase",3]],[["result",6],["arraybase",3]]]],[10,"solve_h_tridiagonal","","Solves a system of linear equations <code>A^H * x = b</code> with …",92,[[["arraybase",3]],[["result",6],["array",6]]]],[10,"solve_h_tridiagonal_into","","Solves a system of linear equations <code>A^H * x = b</code> with …",92,[[["datamut",8],["arraybase",3]],[["result",6],["arraybase",3]]]],[8,"SolveTridiagonalInplace","","",null,null],[10,"solve_tridiagonal_inplace","","Solves a system of linear equations <code>A * x = b</code> tridiagonal …",93,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[10,"solve_t_tridiagonal_inplace","","Solves a system of linear equations <code>A^T * x = b</code> …",93,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[10,"solve_h_tridiagonal_inplace","","Solves a system of linear equations <code>A^H * x = b</code> …",93,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[8,"FactorizeTridiagonal","","An interface for computing LU factorizations of …",null,null],[10,"factorize_tridiagonal","","Computes the LU factorization <code>A = P*L*U</code>, where <code>P</code> is a …",94,[[],[["lufactorizedtridiagonal",3],["result",6]]]],[8,"FactorizeTridiagonalInto","","An interface for computing LU factorizations of …",null,null],[10,"factorize_tridiagonal_into","","Computes the LU factorization <code>A = P*L*U</code>, where <code>P</code> is a …",95,[[],[["lufactorizedtridiagonal",3],["result",6]]]],[8,"DeterminantTridiagonal","","An interface for calculating determinants of tridiagonal …",null,null],[10,"det_tridiagonal","","Computes the determinant of the matrix. Unlike <code>.det()</code> of …",96,[[],["result",6]]],[8,"ReciprocalConditionNumTridiagonal","","An interface for <em>estimating</em> the reciprocal condition …",null,null],[10,"rcond_tridiagonal","","<em>Estimates</em> the reciprocal of the condition number of the …",97,[[],["result",6]]],[8,"ReciprocalConditionNumTridiagonalInto","","An interface for <em>estimating</em> the reciprocal condition …",null,null],[10,"rcond_tridiagonal_into","","<em>Estimates</em> the reciprocal of the condition number of the …",98,[[],["result",6]]],[0,"types","ndarray_linalg","Basic types and their methods for linear algebra",null,null],[8,"Scalar","ndarray_linalg::types","",null,null],[16,"Real","","",99,null],[16,"Complex","","",99,null],[10,"real","","Create a new real number",99,[[]]],[10,"complex","","Create a new complex number",99,[[]]],[10,"from_real","","",99,[[]]],[10,"add_real","","",99,[[]]],[10,"sub_real","","",99,[[]]],[10,"mul_real","","",99,[[]]],[10,"div_real","","",99,[[]]],[10,"add_complex","","",99,[[]]],[10,"sub_complex","","",99,[[]]],[10,"mul_complex","","",99,[[]]],[10,"div_complex","","",99,[[]]],[10,"pow","","",99,[[]]],[10,"powi","","",99,[[["i32",15]]]],[10,"powf","","",99,[[]]],[10,"powc","","",99,[[]]],[10,"re","","Real part",99,[[]]],[10,"im","","Imaginary part",99,[[]]],[10,"as_c","","As a complex number",99,[[]]],[10,"conj","","Complex conjugate",99,[[]]],[10,"abs","","Absolute value",99,[[]]],[10,"square","","Sqaure of absolute value",99,[[]]],[10,"sqrt","","",99,[[]]],[10,"exp","","",99,[[]]],[10,"ln","","",99,[[]]],[10,"sin","","",99,[[]]],[10,"cos","","",99,[[]]],[10,"tan","","",99,[[]]],[10,"asin","","",99,[[]]],[10,"acos","","",99,[[]]],[10,"atan","","",99,[[]]],[10,"sinh","","",99,[[]]],[10,"cosh","","",99,[[]]],[10,"tanh","","",99,[[]]],[10,"asinh","","",99,[[]]],[10,"acosh","","",99,[[]]],[10,"atanh","","",99,[[]]],[10,"rand","","Generate an random number from …",99,[[]]],[8,"Lapack","","Trait for primitive types which implements LAPACK …",null,null],[6,"c32","","",null,null],[6,"c64","","",null,null],[3,"TruncatedEig","ndarray_linalg","Truncated eigenproblem solver",null,null],[12,"constraints","","",44,null],[4,"TruncatedOrder","","Find largest or smallest eigenvalues",null,null],[13,"Largest","","",46,null],[13,"Smallest","","",46,null],[3,"TruncatedSvd","","Truncated singular value decomposition",null,null],[14,"assert_rclose","","",null,null],[14,"assert_aclose","","",null,null],[14,"assert_close_max","","",null,null],[14,"assert_close_l1","","",null,null],[14,"assert_close_l2","","",null,null],[11,"from","ndarray_linalg::solveh","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"vzip","","",0,[[]]],[11,"from","ndarray_linalg::cholesky","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"vzip","","",1,[[]]],[11,"from","ndarray_linalg::diagonal","",100,[[]]],[11,"into","","",100,[[]]],[11,"borrow","","",100,[[]]],[11,"borrow_mut","","",100,[[]]],[11,"try_from","","",100,[[],["result",4]]],[11,"try_into","","",100,[[],["result",4]]],[11,"type_id","","",100,[[],["typeid",3]]],[11,"vzip","","",100,[[]]],[11,"from","ndarray_linalg::error","",24,[[]]],[11,"into","","",24,[[]]],[11,"to_string","","",24,[[],["string",3]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"try_into","","",24,[[],["result",4]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"vzip","","",24,[[]]],[11,"from","ndarray_linalg::krylov::arnoldi","",29,[[]]],[11,"into","","",29,[[]]],[11,"into_iter","","",29,[[]]],[11,"borrow","","",29,[[]]],[11,"borrow_mut","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"try_into","","",29,[[],["result",4]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"vzip","","",29,[[]]],[11,"from","ndarray_linalg::krylov::householder","",30,[[]]],[11,"into","","",30,[[]]],[11,"to_owned","","",30,[[]]],[11,"clone_into","","",30,[[]]],[11,"borrow","","",30,[[]]],[11,"borrow_mut","","",30,[[]]],[11,"try_from","","",30,[[],["result",4]]],[11,"try_into","","",30,[[],["result",4]]],[11,"type_id","","",30,[[],["typeid",3]]],[11,"vzip","","",30,[[]]],[11,"from","ndarray_linalg::krylov::mgs","",31,[[]]],[11,"into","","",31,[[]]],[11,"to_owned","","",31,[[]]],[11,"clone_into","","",31,[[]]],[11,"borrow","","",31,[[]]],[11,"borrow_mut","","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"try_into","","",31,[[],["result",4]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"vzip","","",31,[[]]],[11,"from","ndarray_linalg::krylov","",33,[[]]],[11,"into","","",33,[[]]],[11,"borrow","","",33,[[]]],[11,"borrow_mut","","",33,[[]]],[11,"try_from","","",33,[[],["result",4]]],[11,"try_into","","",33,[[],["result",4]]],[11,"type_id","","",33,[[],["typeid",3]]],[11,"vzip","","",33,[[]]],[11,"from","","",34,[[]]],[11,"into","","",34,[[]]],[11,"to_owned","","",34,[[]]],[11,"clone_into","","",34,[[]]],[11,"borrow","","",34,[[]]],[11,"borrow_mut","","",34,[[]]],[11,"try_from","","",34,[[],["result",4]]],[11,"try_into","","",34,[[],["result",4]]],[11,"type_id","","",34,[[],["typeid",3]]],[11,"vzip","","",34,[[]]],[11,"from","ndarray_linalg::layout","",35,[[]]],[11,"into","","",35,[[]]],[11,"to_owned","","",35,[[]]],[11,"clone_into","","",35,[[]]],[11,"borrow","","",35,[[]]],[11,"borrow_mut","","",35,[[]]],[11,"try_from","","",35,[[],["result",4]]],[11,"try_into","","",35,[[],["result",4]]],[11,"type_id","","",35,[[],["typeid",3]]],[11,"vzip","","",35,[[]]],[11,"from","ndarray_linalg::least_squares","",40,[[]]],[11,"into","","",40,[[]]],[11,"to_owned","","",40,[[]]],[11,"clone_into","","",40,[[]]],[11,"borrow","","",40,[[]]],[11,"borrow_mut","","",40,[[]]],[11,"try_from","","",40,[[],["result",4]]],[11,"try_into","","",40,[[],["result",4]]],[11,"type_id","","",40,[[],["typeid",3]]],[11,"vzip","","",40,[[]]],[11,"from","ndarray_linalg::lobpcg","",44,[[]]],[11,"into","","",44,[[]]],[11,"borrow","","",44,[[]]],[11,"borrow_mut","","",44,[[]]],[11,"try_from","","",44,[[],["result",4]]],[11,"try_into","","",44,[[],["result",4]]],[11,"type_id","","",44,[[],["typeid",3]]],[11,"vzip","","",44,[[]]],[11,"from","","",46,[[]]],[11,"into","","",46,[[]]],[11,"to_owned","","",46,[[]]],[11,"clone_into","","",46,[[]]],[11,"borrow","","",46,[[]]],[11,"borrow_mut","","",46,[[]]],[11,"try_from","","",46,[[],["result",4]]],[11,"try_into","","",46,[[],["result",4]]],[11,"type_id","","",46,[[],["typeid",3]]],[11,"vzip","","",46,[[]]],[11,"from","","",45,[[]]],[11,"into","","",45,[[]]],[11,"borrow","","",45,[[]]],[11,"borrow_mut","","",45,[[]]],[11,"try_from","","",45,[[],["result",4]]],[11,"try_into","","",45,[[],["result",4]]],[11,"type_id","","",45,[[],["typeid",3]]],[11,"vzip","","",45,[[]]],[11,"from","","",101,[[]]],[11,"into","","",101,[[]]],[11,"borrow","","",101,[[]]],[11,"borrow_mut","","",101,[[]]],[11,"try_from","","",101,[[],["result",4]]],[11,"try_into","","",101,[[],["result",4]]],[11,"type_id","","",101,[[],["typeid",3]]],[11,"vzip","","",101,[[]]],[11,"from","ndarray_linalg::norm","",48,[[]]],[11,"into","","",48,[[]]],[11,"borrow","","",48,[[]]],[11,"borrow_mut","","",48,[[]]],[11,"try_from","","",48,[[],["result",4]]],[11,"try_into","","",48,[[],["result",4]]],[11,"type_id","","",48,[[],["typeid",3]]],[11,"vzip","","",48,[[]]],[11,"from","ndarray_linalg::opnorm","",50,[[]]],[11,"into","","",50,[[]]],[11,"to_owned","","",50,[[]]],[11,"clone_into","","",50,[[]]],[11,"borrow","","",50,[[]]],[11,"borrow_mut","","",50,[[]]],[11,"try_from","","",50,[[],["result",4]]],[11,"try_into","","",50,[[],["result",4]]],[11,"type_id","","",50,[[],["typeid",3]]],[11,"vzip","","",50,[[]]],[11,"from","ndarray_linalg::solve","",57,[[]]],[11,"into","","",57,[[]]],[11,"to_owned","","",57,[[]]],[11,"clone_into","","",57,[[]]],[11,"borrow","","",57,[[]]],[11,"borrow_mut","","",57,[[]]],[11,"try_from","","",57,[[],["result",4]]],[11,"try_into","","",57,[[],["result",4]]],[11,"type_id","","",57,[[],["typeid",3]]],[11,"vzip","","",57,[[]]],[11,"from","","",59,[[]]],[11,"into","","",59,[[]]],[11,"to_owned","","",59,[[]]],[11,"clone_into","","",59,[[]]],[11,"borrow","","",59,[[]]],[11,"borrow_mut","","",59,[[]]],[11,"try_from","","",59,[[],["result",4]]],[11,"try_into","","",59,[[],["result",4]]],[11,"type_id","","",59,[[],["typeid",3]]],[11,"vzip","","",59,[[]]],[11,"from","ndarray_linalg::solveh","",69,[[]]],[11,"into","","",69,[[]]],[11,"borrow","","",69,[[]]],[11,"borrow_mut","","",69,[[]]],[11,"try_from","","",69,[[],["result",4]]],[11,"try_into","","",69,[[],["result",4]]],[11,"type_id","","",69,[[],["typeid",3]]],[11,"vzip","","",69,[[]]],[11,"from","ndarray_linalg::svddc","",79,[[]]],[11,"into","","",79,[[]]],[11,"to_owned","","",79,[[]]],[11,"clone_into","","",79,[[]]],[11,"borrow","","",79,[[]]],[11,"borrow_mut","","",79,[[]]],[11,"try_from","","",79,[[],["result",4]]],[11,"try_into","","",79,[[],["result",4]]],[11,"type_id","","",79,[[],["typeid",3]]],[11,"vzip","","",79,[[]]],[11,"from","ndarray_linalg::triangular","",84,[[]]],[11,"into","","",84,[[]]],[11,"to_owned","","",84,[[]]],[11,"clone_into","","",84,[[]]],[11,"borrow","","",84,[[]]],[11,"borrow_mut","","",84,[[]]],[11,"try_from","","",84,[[],["result",4]]],[11,"try_into","","",84,[[],["result",4]]],[11,"type_id","","",84,[[],["typeid",3]]],[11,"vzip","","",84,[[]]],[11,"from","ndarray_linalg::tridiagonal","",89,[[]]],[11,"into","","",89,[[]]],[11,"to_owned","","",89,[[]]],[11,"clone_into","","",89,[[]]],[11,"borrow","","",89,[[]]],[11,"borrow_mut","","",89,[[]]],[11,"try_from","","",89,[[],["result",4]]],[11,"try_into","","",89,[[],["result",4]]],[11,"type_id","","",89,[[],["typeid",3]]],[11,"vzip","","",89,[[]]],[11,"from","","",90,[[]]],[11,"into","","",90,[[]]],[11,"to_owned","","",90,[[]]],[11,"clone_into","","",90,[[]]],[11,"borrow","","",90,[[]]],[11,"borrow_mut","","",90,[[]]],[11,"try_from","","",90,[[],["result",4]]],[11,"try_into","","",90,[[],["result",4]]],[11,"type_id","","",90,[[],["typeid",3]]],[11,"vzip","","",90,[[]]],[11,"fmt","ndarray_linalg::solve","",57,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","ndarray_linalg::layout","",35,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","ndarray_linalg::opnorm","",50,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","ndarray_linalg::solveh","",0,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","ndarray_linalg::triangular","",84,[[["formatter",3]],[["error",3],["result",4]]]],[11,"index","ndarray_linalg::tridiagonal","",90,[[]]],[11,"index","","",90,[[]]],[11,"index_mut","","",90,[[]]],[11,"index_mut","","",90,[[]]],[11,"clone","ndarray_linalg::triangular","",84,[[],["diag",4]]],[11,"clone","ndarray_linalg::svddc","",79,[[],["uvtflag",4]]],[11,"clone","ndarray_linalg::layout","",35,[[],["matrixlayout",4]]],[11,"clone","ndarray_linalg::opnorm","",50,[[],["normtype",4]]],[11,"clone","ndarray_linalg::tridiagonal","",89,[[],["lufactorizedtridiagonal",3]]],[11,"clone","","",90,[[],["tridiagonal",3]]],[11,"clone","ndarray_linalg::solve","",57,[[],["transpose",4]]],[11,"clone","ndarray_linalg::solveh","",0,[[],["uplo",4]]],[11,"eq","ndarray_linalg::svddc","",79,[[["uvtflag",4]],["bool",15]]],[11,"eq","ndarray_linalg::tridiagonal","",89,[[["lufactorizedtridiagonal",3]],["bool",15]]],[11,"ne","","",89,[[["lufactorizedtridiagonal",3]],["bool",15]]],[11,"eq","","",90,[[["tridiagonal",3]],["bool",15]]],[11,"ne","","",90,[[["tridiagonal",3]],["bool",15]]],[11,"eq","ndarray_linalg::layout","",35,[[["matrixlayout",4]],["bool",15]]],[11,"ne","","",35,[[["matrixlayout",4]],["bool",15]]],[11,"solvec_inplace","ndarray_linalg::cholesky","",1,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"invc","","",1,[[],["result",6]]],[11,"invc_into","","",1,[[],["result",6]]],[11,"detc","","",1,[[]]],[11,"ln_detc","","",1,[[]]],[11,"detc_into","","",1,[[]]],[11,"ln_detc_into","","",1,[[]]],[11,"dim","ndarray_linalg::krylov::householder","",30,[[],["usize",15]]],[11,"len","","",30,[[],["usize",15]]],[11,"tolerance","","",30,[[]]],[11,"decompose","","",30,[[["arraybase",3]],["array1",6]]],[11,"coeff","","",30,[[["arraybase",3],["ix1",6]],["array1",6]]],[11,"div_append","","",30,[[["arraybase",3]],["appendresult",4]]],[11,"append","","",30,[[["arraybase",3],["ix1",6]],["appendresult",4]]],[11,"get_q","","",30,[[],["q",6]]],[11,"dim","ndarray_linalg::krylov::mgs","",31,[[],["usize",15]]],[11,"len","","",31,[[],["usize",15]]],[11,"tolerance","","",31,[[]]],[11,"decompose","","",31,[[["arraybase",3]],["array1",6]]],[11,"coeff","","",31,[[["arraybase",3],["ix1",6]],["array1",6]]],[11,"append","","",31,[[["arraybase",3],["ix1",6]],["appendresult",4]]],[11,"div_append","","",31,[[["arraybase",3]],["appendresult",4]]],[11,"get_q","","",31,[[],["q",6]]],[11,"apply_mut","ndarray_linalg::diagonal","",100,[[["arraybase",3]]]],[11,"opnorm","ndarray_linalg::tridiagonal","",90,[[["normtype",4]],["result",6]]],[11,"solve_inplace","ndarray_linalg::solve","",59,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_t_inplace","","",59,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_h_inplace","","",59,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"inv","","",59,[[],[["result",6],["array2",6]]]],[11,"inv_into","","",59,[[],[["result",6],["arraybase",3]]]],[11,"sln_det","","",59,[[],["result",6]]],[11,"sln_det_into","","",59,[[],["result",6]]],[11,"rcond","","",59,[[],["result",6]]],[11,"rcond_into","","",59,[[],["result",6]]],[11,"solveh_inplace","ndarray_linalg::solveh","",69,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"invh","","",69,[[],["result",6]]],[11,"invh_into","","",69,[[],[["result",6],["arraybase",3]]]],[11,"solve_tridiagonal","ndarray_linalg::tridiagonal","",89,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_tridiagonal_into","","",89,[[["datamut",8],["ix2",6],["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_t_tridiagonal","","",89,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_t_tridiagonal_into","","",89,[[["datamut",8],["ix2",6],["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_h_tridiagonal","","",89,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_h_tridiagonal_into","","",89,[[["datamut",8],["ix2",6],["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_tridiagonal","","",90,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_tridiagonal_into","","",90,[[["arraybase",3],["datamut",8],["ix2",6]],[["arraybase",3],["result",6]]]],[11,"solve_t_tridiagonal","","",90,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_t_tridiagonal_into","","",90,[[["arraybase",3],["datamut",8],["ix2",6]],[["arraybase",3],["result",6]]]],[11,"solve_h_tridiagonal","","",90,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_h_tridiagonal_into","","",90,[[["arraybase",3],["datamut",8],["ix2",6]],[["arraybase",3],["result",6]]]],[11,"solve_tridiagonal","","",89,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_tridiagonal_into","","",89,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[11,"solve_t_tridiagonal","","",89,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_t_tridiagonal_into","","",89,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[11,"solve_h_tridiagonal","","",89,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_h_tridiagonal_into","","",89,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[11,"solve_tridiagonal","","",90,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_tridiagonal_into","","",90,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[11,"solve_t_tridiagonal","","",90,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_t_tridiagonal_into","","",90,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[11,"solve_h_tridiagonal","","",90,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_h_tridiagonal_into","","",90,[[["arraybase",3],["datamut",8],["ix1",6]],[["arraybase",3],["result",6]]]],[11,"solve_tridiagonal_inplace","","",89,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_t_tridiagonal_inplace","","",89,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_h_tridiagonal_inplace","","",89,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_tridiagonal_inplace","","",90,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_t_tridiagonal_inplace","","",90,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_h_tridiagonal_inplace","","",90,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"factorize_tridiagonal","","",90,[[],[["lufactorizedtridiagonal",3],["result",6]]]],[11,"factorize_tridiagonal_into","","",90,[[],[["lufactorizedtridiagonal",3],["result",6]]]],[11,"det_tridiagonal","","",90,[[],["result",6]]],[11,"rcond_tridiagonal","","",89,[[],["result",6]]],[11,"rcond_tridiagonal_into","","",89,[[],["result",6]]],[11,"from","ndarray_linalg::error","",24,[[["error",4]]]],[11,"from","","",24,[[["shapeerror",3]]]],[11,"into_iter","ndarray_linalg::lobpcg","",44,[[],["truncatedeigiterator",3]]],[11,"next","ndarray_linalg::krylov::arnoldi","",29,[[],["option",4]]],[11,"clone","ndarray_linalg::krylov::householder","",30,[[],["householder",3]]],[11,"clone","ndarray_linalg::krylov::mgs","",31,[[],["mgs",3]]],[11,"clone","ndarray_linalg::krylov","",34,[[],["strategy",4]]],[11,"clone","ndarray_linalg::least_squares","",40,[[],["leastsquaresresult",3]]],[11,"clone","ndarray_linalg::lobpcg","",46,[[],["order",4]]],[11,"clone","ndarray_linalg::solve","",59,[[],["lufactorized",3]]],[11,"eq","ndarray_linalg::krylov","",34,[[["strategy",4]],["bool",15]]],[11,"fmt","ndarray_linalg::error","",24,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::krylov::householder","",30,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::krylov::mgs","",31,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::krylov","",34,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::least_squares","",40,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::lobpcg","",46,[[["formatter",3]],["result",6]]],[11,"fmt","","",45,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::error","",24,[[["formatter",3]],["result",6]]],[11,"source","","",24,[[],[["option",4],["error",8]]]],[11,"t","ndarray_linalg::solveh","",0,[[],["uplo",4]]],[11,"size","ndarray_linalg::layout","",35,[[]]],[11,"resized","","",35,[[["i32",15]],["matrixlayout",4]]],[11,"lda","","",35,[[],["i32",15]]],[11,"len","","",35,[[],["i32",15]]],[11,"is_empty","","",35,[[],["bool",15]]],[11,"same_order","","",35,[[["matrixlayout",4]],["bool",15]]],[11,"toggle_order","","",35,[[],["matrixlayout",4]]],[11,"t","","Transpose without changing memory representation",35,[[],["matrixlayout",4]]],[11,"new","ndarray_linalg::lobpcg","",44,[[["order",4],["array2",6]],["truncatedeig",3]]],[11,"precision","","",44,[[["f32",15]]]],[11,"maxiter","","",44,[[["usize",15]]]],[11,"orthogonal_to","","",44,[[["array2",6]]]],[11,"precondition_with","","",44,[[["array2",6]]]],[11,"decompose","","",44,[[["usize",15]],["lobpcgresult",4]]],[11,"new","","",101,[[["order",4],["array2",6]],["truncatedsvd",3]]],[11,"precision","","",101,[[["f32",15]]]],[11,"maxiter","","",101,[[["usize",15]]]],[11,"decompose","","",101,[[["usize",15]],[["result",6],["truncatedsvdresult",3]]]],[11,"transpose","ndarray_linalg::opnorm","",50,[[],["normtype",4]]]],"p":[[4,"UPLO"],[3,"CholeskyFactorized"],[8,"Cholesky"],[8,"CholeskyInto"],[8,"CholeskyInplace"],[8,"FactorizeC"],[8,"FactorizeCInto"],[8,"SolveC"],[8,"InverseC"],[8,"InverseCInto"],[8,"DeterminantC"],[8,"DeterminantCInto"],[8,"IntoDiagonal"],[8,"AsDiagonal"],[8,"Eig"],[8,"EigVals"],[8,"Eigh"],[8,"EighInplace"],[8,"EighInto"],[8,"EigValsh"],[8,"EigValshInto"],[8,"EigValshInplace"],[8,"SymmetricSqrt"],[8,"SymmetricSqrtInto"],[4,"LinalgError"],[13,"NotSquare"],[13,"InvalidStride"],[13,"NotStandardShape"],[8,"InnerProduct"],[3,"Arnoldi"],[3,"Householder"],[3,"MGS"],[8,"Orthogonalizer"],[4,"AppendResult"],[4,"Strategy"],[4,"MatrixLayout"],[13,"C"],[13,"F"],[8,"AllocatedArray"],[8,"AllocatedArrayMut"],[3,"LeastSquaresResult"],[8,"LeastSquaresSvd"],[8,"LeastSquaresSvdInto"],[8,"LeastSquaresSvdInPlace"],[3,"TruncatedEig"],[4,"LobpcgResult"],[4,"TruncatedOrder"],[8,"Norm"],[4,"NormalizeAxis"],[8,"LinearOperator"],[4,"NormType"],[8,"OperationNorm"],[8,"QR"],[8,"QRInto"],[8,"QRSquare"],[8,"QRSquareInto"],[8,"QRSquareInplace"],[4,"Transpose"],[8,"Solve"],[3,"LUFactorized"],[8,"Factorize"],[8,"FactorizeInto"],[8,"Inverse"],[8,"InverseInto"],[8,"Determinant"],[8,"DeterminantInto"],[8,"ReciprocalConditionNum"],[8,"ReciprocalConditionNumInto"],[8,"SolveH"],[3,"BKFactorized"],[8,"FactorizeH"],[8,"FactorizeHInto"],[8,"InverseH"],[8,"InverseHInto"],[8,"DeterminantH"],[8,"DeterminantHInto"],[8,"SVD"],[8,"SVDInto"],[8,"SVDInplace"],[4,"UVTFlag"],[8,"SVDDC"],[8,"SVDDCInto"],[8,"SVDDCInplace"],[8,"Trace"],[4,"Diag"],[8,"SolveTriangular"],[8,"SolveTriangularInto"],[8,"SolveTriangularInplace"],[8,"IntoTriangular"],[3,"LUFactorizedTridiagonal"],[3,"Tridiagonal"],[8,"ExtractTridiagonal"],[8,"SolveTridiagonal"],[8,"SolveTridiagonalInplace"],[8,"FactorizeTridiagonal"],[8,"FactorizeTridiagonalInto"],[8,"DeterminantTridiagonal"],[8,"ReciprocalConditionNumTridiagonal"],[8,"ReciprocalConditionNumTridiagonalInto"],[8,"Scalar"],[3,"Diagonal"],[3,"TruncatedSvd"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);