var searchIndex = JSON.parse('{\
"lax":{"doc":"Linear Algebra eXtension (LAX)ndarray-free safe Rust…","i":[[3,"LeastSquaresOutput","lax","Result of LeastSquares",null,null],[12,"singular_values","","singular values",0,null],[12,"rank","","The rank of the input matrix A",0,null],[3,"SVDOutput","","Result of SVD",null,null],[12,"s","","diagonal values",1,null],[12,"u","","Unitary matrix for destination space",1,null],[12,"vt","","Unitary matrix for departure space",1,null],[3,"Tridiagonal","","Represents a tridiagonal matrix as 3 one-dimensional…",null,null],[12,"l","","layout of raw matrix",2,null],[12,"dl","","(n-1) sub-diagonal elements of matrix.",2,null],[12,"d","","(n) diagonal elements of matrix.",2,null],[12,"du","","(n-1) super-diagonal elements of matrix.",2,null],[3,"LUFactorizedTridiagonal","","Represents the LU factorization of a tridiagonal matrix…",null,null],[12,"a","","A tridiagonal matrix which consists of",3,null],[12,"du2","","(n-2) elements of the second super-diagonal of U.",3,null],[12,"ipiv","","The pivot indices that define the permutation matrix `P`.",3,null],[4,"UVTFlag","","Specifies how many of the columns of U and rows of Vᵀ are…",null,null],[13,"Full","","All m columns of U and all n rows of Vᵀ.",4,null],[13,"Some","","The first min(m,n) columns of U and the first min(m,n)…",4,null],[13,"None","","No columns of U or rows of Vᵀ.",4,null],[4,"Diag","","",null,null],[13,"Unit","","",5,null],[13,"NonUnit","","",5,null],[4,"UPLO","","Upper/Lower specification for seveal usages",null,null],[13,"Upper","","",6,null],[13,"Lower","","",6,null],[4,"Transpose","","",null,null],[13,"No","","",7,null],[13,"Transpose","","",7,null],[13,"Hermite","","",7,null],[4,"NormType","","",null,null],[13,"One","","",8,null],[13,"Infinity","","",8,null],[13,"Frobenius","","",8,null],[0,"error","","",null,null],[4,"Error","lax::error","",null,null],[13,"LapackInvalidValue","","",9,null],[12,"return_code","lax::error::Error","",10,null],[13,"LapackComputationalFailure","lax::error","",9,null],[12,"return_code","lax::error::Error","",11,null],[13,"InvalidShape","lax::error","Strides of the array is not supported",9,null],[6,"Result","","",null,null],[8,"AsLapackResult","","",null,null],[10,"as_lapack_result","","",12,[[],["result",6]]],[0,"layout","lax","Memory layout of matrices",null,null],[4,"MatrixLayout","lax::layout","",null,null],[13,"C","","",13,null],[12,"row","lax::layout::MatrixLayout","",14,null],[12,"lda","","",14,null],[13,"F","lax::layout","",13,null],[12,"col","lax::layout::MatrixLayout","",15,null],[12,"lda","","",15,null],[5,"square_transpose","lax::layout","In-place transpose of a square matrix by keeping F/C layout",null,[[["matrixlayout",4]]]],[5,"transpose","","Out-place transpose for general matrix",null,[[["matrixlayout",4]],["matrixlayout",4]]],[11,"size","","",13,[[]]],[11,"resized","","",13,[[],["matrixlayout",4]]],[11,"lda","","",13,[[]]],[11,"len","","",13,[[]]],[11,"is_empty","","",13,[[]]],[11,"same_order","","",13,[[["matrixlayout",4]]]],[11,"toggle_order","","",13,[[]]],[11,"t","","Transpose without changing memory representation",13,[[]]],[6,"Pivot","lax","",null,null],[8,"Cholesky_","","",null,null],[10,"cholesky","","Cholesky: wrapper of `*potrf`",16,[[["matrixlayout",4],["uplo",4]],["result",6]]],[10,"inv_cholesky","","Wrapper of `*potri`",16,[[["matrixlayout",4],["uplo",4]],["result",6]]],[10,"solve_cholesky","","Wrapper of `*potrs`",16,[[["matrixlayout",4],["uplo",4]],["result",6]]],[8,"Eig_","","Wraps `*geev` for general matrices",null,null],[10,"eig","","Calculate Right eigenvalue",17,[[["matrixlayout",4]],["result",6]]],[8,"Eigh_","","",null,null],[10,"eigh","","Wraps `*syev` for real and `*heev` for complex",18,[[["matrixlayout",4],["uplo",4]],[["vec",3],["result",6]]]],[10,"eigh_generalized","","Wraps `*syegv` for real and `*heegv` for complex",18,[[["matrixlayout",4],["uplo",4]],[["vec",3],["result",6]]]],[8,"LeastSquaresSvdDivideConquer_","","Wraps `*gelsd`",null,null],[10,"least_squares","","",19,[[["matrixlayout",4]],[["leastsquaresoutput",3],["result",6]]]],[10,"least_squares_nrhs","","",19,[[["matrixlayout",4]],[["leastsquaresoutput",3],["result",6]]]],[8,"OperatorNorm_","","",null,null],[10,"opnorm","","",20,[[["matrixlayout",4],["normtype",4]]]],[8,"QR_","","",null,null],[10,"householder","","Execute Householder reflection as the first step of…",21,[[["matrixlayout",4]],[["result",6],["vec",3]]]],[10,"q","","Reconstruct Q-matrix from Householder-reflectors",21,[[["matrixlayout",4]],["result",6]]],[10,"qr","","Execute QR-decomposition at once",21,[[["matrixlayout",4]],[["result",6],["vec",3]]]],[8,"Rcond_","","",null,null],[10,"rcond","","Estimates the the reciprocal of the condition number of…",22,[[["matrixlayout",4]],["result",6]]],[8,"Solve_","","",null,null],[10,"lu","","Computes the LU factorization of a general `m x n` matrix…",23,[[["matrixlayout",4]],[["pivot",6],["result",6]]]],[10,"inv","","",23,[[["matrixlayout",4],["pivot",6]],["result",6]]],[10,"solve","","",23,[[["matrixlayout",4],["pivot",6],["transpose",4]],["result",6]]],[8,"Solveh_","","",null,null],[10,"bk","","Bunch-Kaufman: wrapper of `*sytrf` and `*hetrf`",24,[[["matrixlayout",4],["uplo",4]],[["pivot",6],["result",6]]]],[10,"invh","","Wrapper of `*sytri` and `*hetri`",24,[[["matrixlayout",4],["uplo",4],["pivot",6]],["result",6]]],[10,"solveh","","Wrapper of `*sytrs` and `*hetrs`",24,[[["matrixlayout",4],["uplo",4],["pivot",6]],["result",6]]],[8,"SVD_","","Wraps `*gesvd`",null,null],[10,"svd","","Calculate singular value decomposition $ A = U \\\\Sigma V^T $",25,[[["matrixlayout",4]],[["result",6],["svdoutput",3]]]],[8,"SVDDC_","","",null,null],[10,"svddc","","",26,[[["matrixlayout",4],["uvtflag",4]],[["result",6],["svdoutput",3]]]],[8,"Triangular_","","Wraps `*trtri` and `*trtrs`",null,null],[10,"solve_triangular","","",27,[[["matrixlayout",4],["uplo",4],["diag",4]],["result",6]]],[8,"Tridiagonal_","","Wraps `*gttrf`, `*gtcon` and `*gttrs`",null,null],[10,"lu_tridiagonal","","Computes the LU factorization of a tridiagonal `m x n`…",28,[[["tridiagonal",3]],[["result",6],["lufactorizedtridiagonal",3]]]],[10,"rcond_tridiagonal","","",28,[[["lufactorizedtridiagonal",3]],["result",6]]],[10,"solve_tridiagonal","","",28,[[["matrixlayout",4],["transpose",4],["lufactorizedtridiagonal",3]],["result",6]]],[8,"Lapack","","Trait for primitive types which implements LAPACK…",null,null],[11,"t","","",6,[[]]],[11,"transpose","","",8,[[]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","lax::error","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_string","","",9,[[],["string",3]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","lax::layout","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"clone","","",13,[[],["matrixlayout",4]]],[11,"clone","lax","",4,[[],["uvtflag",4]]],[11,"clone","","",5,[[],["diag",4]]],[11,"clone","","",2,[[],["tridiagonal",3]]],[11,"clone","","",3,[[],["lufactorizedtridiagonal",3]]],[11,"clone","","",6,[[],["uplo",4]]],[11,"clone","","",7,[[],["transpose",4]]],[11,"clone","","",8,[[],["normtype",4]]],[11,"eq","lax::layout","",13,[[["matrixlayout",4]]]],[11,"ne","","",13,[[["matrixlayout",4]]]],[11,"eq","lax","",4,[[["uvtflag",4]]]],[11,"eq","","",2,[[["tridiagonal",3]]]],[11,"ne","","",2,[[["tridiagonal",3]]]],[11,"eq","","",3,[[["lufactorizedtridiagonal",3]]]],[11,"ne","","",3,[[["lufactorizedtridiagonal",3]]]],[11,"fmt","lax::error","",9,[[["formatter",3]],["result",6]]],[11,"fmt","lax::layout","",13,[[["formatter",3]],["result",6]]],[11,"fmt","lax","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","lax::error","",9,[[["formatter",3]],["result",6]]],[11,"index","lax","",2,[[]]],[11,"index","","",2,[[]]],[11,"index_mut","","",2,[[]]],[11,"index_mut","","",2,[[]]]],"p":[[3,"LeastSquaresOutput"],[3,"SVDOutput"],[3,"Tridiagonal"],[3,"LUFactorizedTridiagonal"],[4,"UVTFlag"],[4,"Diag"],[4,"UPLO"],[4,"Transpose"],[4,"NormType"],[4,"Error"],[13,"LapackInvalidValue"],[13,"LapackComputationalFailure"],[8,"AsLapackResult"],[4,"MatrixLayout"],[13,"C"],[13,"F"],[8,"Cholesky_"],[8,"Eig_"],[8,"Eigh_"],[8,"LeastSquaresSvdDivideConquer_"],[8,"OperatorNorm_"],[8,"QR_"],[8,"Rcond_"],[8,"Solve_"],[8,"Solveh_"],[8,"SVD_"],[8,"SVDDC_"],[8,"Triangular_"],[8,"Tridiagonal_"]]},\
"ndarray_linalg":{"doc":"The `ndarray-linalg` crate provides linear algebra…","i":[[3,"TruncatedEig","ndarray_linalg","Truncated eigenproblem solver",null,null],[12,"constraints","","",0,null],[3,"TruncatedSvd","","Truncated singular value decomposition",null,null],[4,"TruncatedOrder","","Find largest or smallest eigenvalues",null,null],[13,"Largest","","",1,null],[13,"Smallest","","",1,null],[0,"assert","","Assertions for array",null,null],[5,"rclose","ndarray_linalg::assert","check two values are close in terms of the relative…",null,[[["scalar",8]]]],[5,"aclose","","check two values are close in terms of the absolute…",null,[[["scalar",8]]]],[5,"close_max","","check two arrays are close in maximum norm",null,[[["arraybase",3],["arraybase",3]]]],[5,"close_l1","","check two arrays are close in L1 norm",null,[[["arraybase",3],["arraybase",3]]]],[5,"close_l2","","check two arrays are close in L2 norm",null,[[["arraybase",3],["arraybase",3]]]],[0,"cholesky","ndarray_linalg","Cholesky decomposition of Hermitian (or real symmetric)…",null,null],[4,"UPLO","ndarray_linalg::cholesky","Upper/Lower specification for seveal usages",null,null],[13,"Upper","","",2,null],[13,"Lower","","",2,null],[3,"CholeskyFactorized","","Cholesky decomposition of Hermitian (or real symmetric)…",null,null],[12,"factor","","`L` from the decomposition `A = L * L^H` or `U` from the…",3,null],[12,"uplo","","If this is `UPLO::Lower`, then `self.factor` is `L`. If…",3,null],[8,"Cholesky","","Cholesky decomposition of Hermitian (or real symmetric)…",null,null],[16,"Output","","",4,null],[10,"cholesky","","Computes the Cholesky decomposition of the Hermitian (or…",4,[[["uplo",4]],["result",6]]],[8,"CholeskyInto","","Cholesky decomposition of Hermitian (or real symmetric)…",null,null],[16,"Output","","",5,null],[10,"cholesky_into","","Computes the Cholesky decomposition of the Hermitian (or…",5,[[["uplo",4]],["result",6]]],[8,"CholeskyInplace","","Cholesky decomposition of Hermitian (or real symmetric)…",null,null],[10,"cholesky_inplace","","Computes the Cholesky decomposition of the Hermitian (or…",6,[[["uplo",4]],["result",6]]],[8,"FactorizeC","","Cholesky decomposition of Hermitian (or real symmetric)…",null,null],[10,"factorizec","","Computes the Cholesky decomposition of the Hermitian (or…",7,[[["uplo",4]],[["choleskyfactorized",3],["result",6]]]],[8,"FactorizeCInto","","Cholesky decomposition of Hermitian (or real symmetric)…",null,null],[10,"factorizec_into","","Computes the Cholesky decomposition of the Hermitian (or…",8,[[["uplo",4]],[["choleskyfactorized",3],["result",6]]]],[8,"SolveC","","Solve systems of linear equations with Hermitian (or real…",null,null],[11,"solvec","","Solves a system of linear equations `A * x = b` with…",9,[[["arraybase",3]],[["array1",6],["result",6]]]],[11,"solvec_into","","Solves a system of linear equations `A * x = b` with…",9,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[10,"solvec_inplace","","Solves a system of linear equations `A * x = b` with…",9,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[8,"InverseC","","Inverse of Hermitian (or real symmetric) positive definite…",null,null],[16,"Output","","",10,null],[10,"invc","","Computes the inverse of the Hermitian (or real symmetric)…",10,[[],["result",6]]],[8,"InverseCInto","","Inverse of Hermitian (or real symmetric) positive definite…",null,null],[16,"Output","","",11,null],[10,"invc_into","","Computes the inverse of the Hermitian (or real symmetric)…",11,[[],["result",6]]],[8,"DeterminantC","","Determinant of Hermitian (or real symmetric) positive…",null,null],[16,"Output","","",12,null],[10,"detc","","Computes the determinant of the Hermitian (or real…",12,[[]]],[10,"ln_detc","","Computes the natural log of the determinant of the…",12,[[]]],[8,"DeterminantCInto","","Determinant of Hermitian (or real symmetric) positive…",null,null],[16,"Output","","",13,null],[10,"detc_into","","Computes the determinant of the Hermitian (or real…",13,[[]]],[10,"ln_detc_into","","Computes the natural log of the determinant of the…",13,[[]]],[11,"into_lower","","Returns `L` from the Cholesky decomposition `A = L * L^H`.",3,[[],[["arraybase",3],["ix2",6]]]],[11,"into_upper","","Returns `U` from the Cholesky decomposition `A = U^H * U`.",3,[[],[["arraybase",3],["ix2",6]]]],[0,"convert","ndarray_linalg","utilities for convert array",null,null],[5,"into_col","ndarray_linalg::convert","",null,[[["arraybase",3],["ix1",6]],[["arraybase",3],["ix2",6]]]],[5,"into_row","","",null,[[["arraybase",3],["ix1",6]],[["arraybase",3],["ix2",6]]]],[5,"flatten","","",null,[[["arraybase",3],["ix2",6]],[["arraybase",3],["ix1",6]]]],[5,"into_matrix","","",null,[[["matrixlayout",4],["vec",3]],[["result",6],["arraybase",3]]]],[5,"replicate","","",null,[[["arraybase",3]],["arraybase",3]]],[5,"transpose_data","","",null,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[5,"generalize","","",null,[[["array",6]],["arraybase",3]]],[0,"diagonal","ndarray_linalg","Vector as a Diagonal matrix",null,null],[3,"Diagonal","ndarray_linalg::diagonal","Vector as a Diagonal matrix",null,null],[8,"IntoDiagonal","","",null,null],[10,"into_diagonal","","",14,[[],["diagonal",3]]],[8,"AsDiagonal","","",null,null],[10,"as_diagonal","","",15,[[],[["viewrepr",3],["diagonal",3]]]],[0,"eig","ndarray_linalg","Eigenvalue decomposition for non-symmetric square matrices",null,null],[8,"Eig","ndarray_linalg::eig","Eigenvalue decomposition of general matrix reference",null,null],[16,"EigVal","","EigVec is the right eivenvector",16,null],[16,"EigVec","","",16,null],[10,"eig","","Calculate eigenvalues with the right eigenvector",16,[[],["result",6]]],[8,"EigVals","","Calculate eigenvalues without eigenvectors",null,null],[16,"EigVal","","",17,null],[10,"eigvals","","",17,[[],["result",6]]],[0,"eigh","ndarray_linalg","Eigenvalue decomposition for Hermite matrices",null,null],[8,"Eigh","ndarray_linalg::eigh","Eigenvalue decomposition of Hermite matrix reference",null,null],[16,"EigVal","","",18,null],[16,"EigVec","","",18,null],[10,"eigh","","",18,[[["uplo",4]],["result",6]]],[8,"EighInplace","","Eigenvalue decomposition of mutable reference of Hermite…",null,null],[16,"EigVal","","",19,null],[10,"eigh_inplace","","",19,[[["uplo",4]],["result",6]]],[8,"EighInto","","Eigenvalue decomposition of Hermite matrix",null,null],[16,"EigVal","","",20,null],[10,"eigh_into","","",20,[[["uplo",4]],["result",6]]],[8,"EigValsh","","Calculate eigenvalues without eigenvectors",null,null],[16,"EigVal","","",21,null],[10,"eigvalsh","","",21,[[["uplo",4]],["result",6]]],[8,"EigValshInto","","Calculate eigenvalues without eigenvectors",null,null],[16,"EigVal","","",22,null],[10,"eigvalsh_into","","",22,[[["uplo",4]],["result",6]]],[8,"EigValshInplace","","Calculate eigenvalues without eigenvectors",null,null],[16,"EigVal","","",23,null],[10,"eigvalsh_inplace","","",23,[[["uplo",4]],["result",6]]],[8,"SymmetricSqrt","","Calculate symmetric square-root matrix using `eigh`",null,null],[16,"Output","","",24,null],[10,"ssqrt","","",24,[[["uplo",4]],["result",6]]],[8,"SymmetricSqrtInto","","Calculate symmetric square-root matrix using `eigh`",null,null],[16,"Output","","",25,null],[10,"ssqrt_into","","",25,[[["uplo",4]],["result",6]]],[0,"error","ndarray_linalg","Define Errors",null,null],[4,"LinalgError","ndarray_linalg::error","Master Error type of this crate",null,null],[13,"NotSquare","","Matrix is not square",26,null],[12,"rows","ndarray_linalg::error::LinalgError","",27,null],[12,"cols","","",27,null],[13,"Lapack","ndarray_linalg::error","LAPACK subroutine returns non-zero code",26,null],[13,"InvalidStride","","Strides of the array is not supported",26,null],[12,"s0","ndarray_linalg::error::LinalgError","",28,null],[12,"s1","","",28,null],[13,"MemoryNotCont","ndarray_linalg::error","Memory is not aligned continously",26,null],[13,"NotStandardShape","","Obj cannot be made from a (rows, cols) matrix",26,null],[12,"obj","ndarray_linalg::error::LinalgError","",29,null],[12,"rows","","",29,null],[12,"cols","","",29,null],[13,"Shape","ndarray_linalg::error","Strides of the array is not supported",26,null],[6,"Result","","",null,null],[0,"generate","ndarray_linalg","Generator functions for matrices",null,null],[5,"conjugate","ndarray_linalg::generate","Hermite conjugate matrix",null,[[["arraybase",3]],[["arraybase",3],["ix2",6]]]],[5,"random","","Generate random array",null,[[],["arraybase",3]]],[5,"random_unitary","","Generate random unitary matrix using QR decomposition",null,[[],["array2",6]]],[5,"random_regular","","Generate random regular matrix",null,[[],["array2",6]]],[5,"random_hermite","","Random Hermite matrix",null,[[],[["arraybase",3],["ix2",6]]]],[5,"random_hpd","","Random Hermite Positive-definite matrix",null,[[],[["arraybase",3],["ix2",6]]]],[5,"from_diag","","construct matrix from diag",null,[[],["array2",6]]],[5,"hstack","","stack vectors into matrix horizontally",null,[[],[["array",6],["result",6]]]],[5,"vstack","","stack vectors into matrix vertically",null,[[],[["array",6],["result",6]]]],[0,"inner","ndarray_linalg","",null,null],[8,"InnerProduct","ndarray_linalg::inner","Inner Product",null,null],[16,"Elem","","",30,null],[10,"inner","","Inner product `(self.conjugate, rhs)",30,[[["arraybase",3]]]],[0,"krylov","ndarray_linalg","Krylov subspace methods",null,null],[4,"AppendResult","ndarray_linalg::krylov","",null,null],[13,"Added","","",31,null],[13,"Dependent","","",31,null],[4,"Strategy","","Strategy for linearly dependent vectors appearing in…",null,null],[13,"Terminate","","Terminate iteration if dependent vector comes",32,null],[13,"Skip","","Skip dependent vector",32,null],[13,"Full","","Orthogonalize dependent vector without adding to Q, i.e. R…",32,null],[5,"qr","","Online QR decomposition using arbitrary orthogonalizer",null,[[["strategy",4]]]],[0,"arnoldi","","Arnoldi iteration",null,null],[3,"Arnoldi","ndarray_linalg::krylov::arnoldi","Execute Arnoldi iteration as Rust iterator",null,null],[5,"arnoldi_householder","","Utility to execute Arnoldi iteration with Householder…",null,[[["arraybase",3],["ix1",6]]]],[5,"arnoldi_mgs","","Utility to execute Arnoldi iteration with modified…",null,[[["arraybase",3],["ix1",6]]]],[11,"new","","Create an Arnoldi iterator from any linear operator `a`",33,[[["arraybase",3],["ix1",6]]]],[11,"dim","","Dimension of Krylov subspace",33,[[]]],[11,"complete","","Iterate until convergent",33,[[]]],[0,"householder","ndarray_linalg::krylov","Householder reflection",null,null],[3,"Householder","ndarray_linalg::krylov::householder","Iterative orthogonalizer using Householder reflection",null,null],[5,"calc_reflector","","Calc a reflactor `w` from a vector `x`",null,[[["arraybase",3]]]],[5,"reflect","","Take a reflection `P = I - 2ww^T`",null,[[["arraybase",3],["arraybase",3]]]],[5,"householder","","Online QR decomposition using Householder reflection",null,[[["strategy",4]]]],[11,"new","","Create a new orthogonalizer",34,[[]]],[11,"forward_reflection","","Take forward reflection `P = P_l ... P_1`",34,[[["arraybase",3]]]],[11,"backward_reflection","","Take backward reflection `P = P_1 ... P_l`",34,[[["arraybase",3]]]],[0,"mgs","ndarray_linalg::krylov","Modified Gram-Schmit orthogonalizer",null,null],[3,"MGS","ndarray_linalg::krylov::mgs","Iterative orthogonalizer using modified Gram-Schmit…",null,null],[5,"mgs","","Online QR decomposition using modified Gram-Schmit algorithm",null,[[["strategy",4]]]],[11,"new","","Create an empty orthogonalizer",35,[[]]],[6,"Q","ndarray_linalg::krylov","Q-matrix",null,null],[6,"R","","R-matrix",null,null],[6,"H","","H-matrix",null,null],[6,"Coefficients","","Array type for coefficients to the current basis",null,null],[8,"Orthogonalizer","","Trait for creating orthogonal basis from iterator of arrays",null,null],[16,"Elem","","",36,null],[10,"dim","","Dimension of input array",36,[[]]],[10,"len","","Number of cached basis",36,[[]]],[11,"is_full","","check if the basis spans entire space",36,[[]]],[11,"is_empty","","",36,[[]]],[10,"tolerance","","",36,[[]]],[10,"decompose","","Decompose given vector into the span of current basis and…",36,[[["arraybase",3]],["coefficients",6]]],[10,"coeff","","Calculate the coefficient to the current basis basis",36,[[["arraybase",3],["ix1",6]],["coefficients",6]]],[10,"append","","Add new vector if the residual is larger than relative…",36,[[["arraybase",3],["ix1",6]],["appendresult",4]]],[10,"div_append","","Add new vector if the residual is larger than relative…",36,[[["arraybase",3]],["appendresult",4]]],[10,"get_q","","Get Q-matrix of generated basis",36,[[],["q",6]]],[11,"into_coeff","","",31,[[],["coefficients",6]]],[11,"is_dependent","","",31,[[]]],[11,"coeff","","",31,[[],["coefficients",6]]],[11,"residual_norm","","",31,[[]]],[0,"layout","ndarray_linalg","Convert ndarray into LAPACK-compatible matrix format",null,null],[4,"MatrixLayout","ndarray_linalg::layout","",null,null],[13,"C","","",37,null],[12,"row","ndarray_linalg::layout::MatrixLayout","",38,null],[12,"lda","","",38,null],[13,"F","ndarray_linalg::layout","",37,null],[12,"col","ndarray_linalg::layout::MatrixLayout","",39,null],[12,"lda","","",39,null],[8,"AllocatedArray","ndarray_linalg::layout","",null,null],[16,"Elem","","",40,null],[10,"layout","","",40,[[],[["matrixlayout",4],["result",6]]]],[10,"square_layout","","",40,[[],[["matrixlayout",4],["result",6]]]],[10,"ensure_square","","Returns Ok iff the matrix is square (without computing the…",40,[[],["result",6]]],[10,"as_allocated","","",40,[[],["result",6]]],[8,"AllocatedArrayMut","","",null,null],[10,"as_allocated_mut","","",41,[[],["result",6]]],[0,"least_squares","ndarray_linalg","Least SquaresCompute a least-squares solution to the…",null,null],[3,"LeastSquaresResult","ndarray_linalg::least_squares","Result of a LeastSquares computation",null,null],[12,"singular_values","","The singular values of the matrix A in `Ax = b`",42,null],[12,"solution","","The solution vector or matrix `x` which is the best…",42,null],[12,"rank","","The rank of the matrix A in `Ax = b`",42,null],[12,"residual_sum_of_squares","","If n < m and rank(A) == n, the sum of squares If b is a (m…",42,null],[8,"LeastSquaresSvd","","Solve least squares for immutable references",null,null],[10,"least_squares","","Solve a least squares problem of the form `Ax = rhs` by…",43,[[["arraybase",3]],[["result",6],["leastsquaresresult",3]]]],[8,"LeastSquaresSvdInto","","Solve least squares for owned matrices",null,null],[10,"least_squares_into","","Solve a least squares problem of the form `Ax = rhs` by…",44,[[["arraybase",3]],[["result",6],["leastsquaresresult",3]]]],[8,"LeastSquaresSvdInPlace","","Solve least squares for mutable references, overwriting…",null,null],[10,"least_squares_in_place","","Solve a least squares problem of the form `Ax = rhs` by…",45,[[["arraybase",3]],[["result",6],["leastsquaresresult",3]]]],[0,"lobpcg","ndarray_linalg","",null,null],[3,"TruncatedEig","ndarray_linalg::lobpcg","Truncated eigenproblem solver",null,null],[12,"constraints","","",0,null],[3,"TruncatedSvd","","Truncated singular value decomposition",null,null],[4,"LobpcgResult","","The result of the eigensolver",null,null],[13,"Ok","","",46,null],[13,"Err","","",46,null],[13,"NoResult","","",46,null],[4,"TruncatedOrder","","Find largest or smallest eigenvalues",null,null],[13,"Largest","","",1,null],[13,"Smallest","","",1,null],[5,"lobpcg","","Eigenvalue solver for large symmetric positive definite…",null,[[["fn",8],["scalar",8],["array2",6],["partialord",8],["option",4],["float",8],["lapack",8],["default",8],["scalaroperand",8],["order",4],["fn",8]],[["lobpcgresult",4],["float",8],["scalar",8],["lapack",8],["scalaroperand",8],["default",8],["partialord",8]]]],[11,"new","ndarray_linalg","",0,[[["order",4],["array2",6]],["truncatedeig",3]]],[11,"precision","","",0,[[]]],[11,"maxiter","","",0,[[]]],[11,"orthogonal_to","","",0,[[["array2",6]]]],[11,"precondition_with","","",0,[[["array2",6]]]],[11,"decompose","","",0,[[],["lobpcgresult",4]]],[11,"new","","",47,[[["order",4],["array2",6]],["truncatedsvd",3]]],[11,"precision","","",47,[[]]],[11,"maxiter","","",47,[[]]],[11,"decompose","","",47,[[],[["result",6],["truncatedsvdresult",3]]]],[0,"norm","","Norm of vectors",null,null],[4,"NormalizeAxis","ndarray_linalg::norm","",null,null],[13,"Row","","",48,null],[13,"Column","","",48,null],[5,"normalize","","normalize in L2 norm",null,[[["arraybase",3],["normalizeaxis",4],["ix2",6]]]],[8,"Norm","","Define norm as a metric linear space (not as a matrix)",null,null],[16,"Output","","",49,null],[11,"norm","","rename of `norm_l2`",49,[[]]],[10,"norm_l1","","L-1 norm",49,[[]]],[10,"norm_l2","","L-2 norm",49,[[]]],[10,"norm_max","","maximum norm",49,[[]]],[0,"operator","ndarray_linalg","Linear operator algebra",null,null],[8,"LinearOperator","ndarray_linalg::operator","Abstracted linear operator as an action to vector…",null,null],[16,"Elem","","",50,null],[11,"apply","","Apply operator out-place",50,[[["arraybase",3]],["array1",6]]],[11,"apply_mut","","Apply operator in-place",50,[[["arraybase",3]]]],[11,"apply_into","","Apply operator with move",50,[[["arraybase",3],["ix1",6]],[["arraybase",3],["ix1",6]]]],[11,"apply2","","Apply operator to matrix out-place",50,[[["arraybase",3]],["array2",6]]],[11,"apply2_mut","","Apply operator to matrix in-place",50,[[["arraybase",3]]]],[11,"apply2_into","","Apply operator to matrix with move",50,[[["arraybase",3],["ix2",6]],[["arraybase",3],["ix2",6]]]],[0,"opnorm","ndarray_linalg","Operator norm",null,null],[4,"NormType","ndarray_linalg::opnorm","",null,null],[13,"One","","",51,null],[13,"Infinity","","",51,null],[13,"Frobenius","","",51,null],[8,"OperationNorm","","Operator norm using `*lange` LAPACK routines",null,null],[16,"Output","","the value of norm",52,null],[10,"opnorm","","",52,[[["normtype",4]],["result",6]]],[11,"opnorm_one","","the one norm of a matrix (maximum column sum)",52,[[],["result",6]]],[11,"opnorm_inf","","the infinity norm of a matrix (maximum row sum)",52,[[],["result",6]]],[11,"opnorm_fro","","the Frobenius norm of a matrix (square root of sum of…",52,[[],["result",6]]],[0,"qr","ndarray_linalg","QR decomposition",null,null],[4,"UPLO","ndarray_linalg::qr","Upper/Lower specification for seveal usages",null,null],[13,"Upper","","",2,null],[13,"Lower","","",2,null],[8,"QR","","QR decomposition for matrix reference",null,null],[16,"Q","","",53,null],[16,"R","","",53,null],[10,"qr","","",53,[[],["result",6]]],[8,"QRInto","","QR decomposition",null,null],[16,"Q","","",54,null],[16,"R","","",54,null],[10,"qr_into","","",54,[[],["result",6]]],[8,"QRSquare","","QR decomposition for square matrix reference",null,null],[16,"Q","","",55,null],[16,"R","","",55,null],[10,"qr_square","","",55,[[],["result",6]]],[8,"QRSquareInto","","QR decomposition for square matrix",null,null],[16,"R","","",56,null],[10,"qr_square_into","","",56,[[],["result",6]]],[8,"QRSquareInplace","","QR decomposition for mutable reference of square matrix",null,null],[16,"R","","",57,null],[10,"qr_square_inplace","","",57,[[],["result",6]]],[0,"solve","ndarray_linalg","Solve systems of linear equations and invert matrices",null,null],[6,"Pivot","ndarray_linalg::solve","",null,null],[4,"Transpose","","",null,null],[13,"No","","",58,null],[13,"Transpose","","",58,null],[13,"Hermite","","",58,null],[3,"LUFactorized","","Represents the LU factorization of a matrix `A` as `A =…",null,null],[12,"a","","The factors `L` and `U`; the unit diagonal elements of `L`…",59,null],[12,"ipiv","","The pivot indices that define the permutation matrix `P`.",59,null],[8,"Solve","","An interface for solving systems of linear equations.",null,null],[11,"solve","","Solves a system of linear equations `A * x = b` where `A`…",60,[[["arraybase",3]],[["array1",6],["result",6]]]],[11,"solve_into","","Solves a system of linear equations `A * x = b` where `A`…",60,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[10,"solve_inplace","","Solves a system of linear equations `A * x = b` where `A`…",60,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[11,"solve_t","","Solves a system of linear equations `A^T * x = b` where…",60,[[["arraybase",3]],[["array1",6],["result",6]]]],[11,"solve_t_into","","Solves a system of linear equations `A^T * x = b` where…",60,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[10,"solve_t_inplace","","Solves a system of linear equations `A^T * x = b` where…",60,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[11,"solve_h","","Solves a system of linear equations `A^H * x = b` where…",60,[[["arraybase",3]],[["array1",6],["result",6]]]],[11,"solve_h_into","","Solves a system of linear equations `A^H * x = b` where…",60,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[10,"solve_h_inplace","","Solves a system of linear equations `A^H * x = b` where…",60,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[8,"Factorize","","An interface for computing LU factorizations of matrix refs.",null,null],[10,"factorize","","Computes the LU factorization `A = P*L*U`, where `P` is a…",61,[[],[["lufactorized",3],["result",6]]]],[8,"FactorizeInto","","An interface for computing LU factorizations of matrices.",null,null],[10,"factorize_into","","Computes the LU factorization `A = P*L*U`, where `P` is a…",62,[[],[["lufactorized",3],["result",6]]]],[8,"Inverse","","An interface for inverting matrix refs.",null,null],[16,"Output","","",63,null],[10,"inv","","Computes the inverse of the matrix.",63,[[],["result",6]]],[8,"InverseInto","","An interface for inverting matrices.",null,null],[16,"Output","","",64,null],[10,"inv_into","","Computes the inverse of the matrix.",64,[[],["result",6]]],[8,"Determinant","","An interface for calculating determinants of matrix refs.",null,null],[11,"det","","Computes the determinant of the matrix.",65,[[],["result",6]]],[10,"sln_det","","Computes the `(sign, natural_log)` of the determinant of…",65,[[],["result",6]]],[8,"DeterminantInto","","An interface for calculating determinants of matrices.",null,null],[11,"det_into","","Computes the determinant of the matrix.",66,[[],["result",6]]],[10,"sln_det_into","","Computes the `(sign, natural_log)` of the determinant of…",66,[[],["result",6]]],[8,"ReciprocalConditionNum","","An interface for estimating the reciprocal condition…",null,null],[10,"rcond","","Estimates the reciprocal of the condition number of the…",67,[[],["result",6]]],[8,"ReciprocalConditionNumInto","","An interface for estimating the reciprocal condition…",null,null],[10,"rcond_into","","Estimates the reciprocal of the condition number of the…",68,[[],["result",6]]],[0,"solveh","ndarray_linalg","Solve Hermitian (or real symmetric) linear problems and…",null,null],[6,"Pivot","ndarray_linalg::solveh","",null,null],[4,"UPLO","","Upper/Lower specification for seveal usages",null,null],[13,"Upper","","",2,null],[13,"Lower","","",2,null],[3,"BKFactorized","","Represents the Bunch–Kaufman factorization of a Hermitian…",null,null],[12,"a","","",69,null],[12,"ipiv","","",69,null],[8,"SolveH","","An interface for solving systems of Hermitian (or real…",null,null],[11,"solveh","","Solves a system of linear equations `A * x = b` with…",70,[[["arraybase",3]],[["array1",6],["result",6]]]],[11,"solveh_into","","Solves a system of linear equations `A * x = b` with…",70,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[10,"solveh_inplace","","Solves a system of linear equations `A * x = b` with…",70,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[8,"FactorizeH","","An interface for computing the Bunch–Kaufman factorization…",null,null],[10,"factorizeh","","Computes the Bunch–Kaufman factorization of a Hermitian…",71,[[],[["bkfactorized",3],["result",6]]]],[8,"FactorizeHInto","","An interface for computing the Bunch–Kaufman factorization…",null,null],[10,"factorizeh_into","","Computes the Bunch–Kaufman factorization of a Hermitian…",72,[[],[["bkfactorized",3],["result",6]]]],[8,"InverseH","","An interface for inverting Hermitian (or real symmetric)…",null,null],[16,"Output","","",73,null],[10,"invh","","Computes the inverse of the Hermitian (or real symmetric)…",73,[[],["result",6]]],[8,"InverseHInto","","An interface for inverting Hermitian (or real symmetric)…",null,null],[16,"Output","","",74,null],[10,"invh_into","","Computes the inverse of the Hermitian (or real symmetric)…",74,[[],["result",6]]],[8,"DeterminantH","","An interface for calculating determinants of Hermitian (or…",null,null],[16,"Elem","","The element type of the matrix.",75,null],[10,"deth","","Computes the determinant of the Hermitian (or real…",75,[[],["result",6]]],[10,"sln_deth","","Computes the `(sign, natural_log)` of the determinant of…",75,[[],["result",6]]],[8,"DeterminantHInto","","An interface for calculating determinants of Hermitian (or…",null,null],[16,"Elem","","The element type of the matrix.",76,null],[10,"deth_into","","Computes the determinant of the Hermitian (or real…",76,[[],["result",6]]],[10,"sln_deth_into","","Computes the `(sign, natural_log)` of the determinant of…",76,[[],["result",6]]],[11,"deth","","Computes the determinant of the factorized Hermitian (or…",69,[[]]],[11,"sln_deth","","Computes the `(sign, natural_log)` of the determinant of…",69,[[]]],[11,"deth_into","","Computes the determinant of the factorized Hermitian (or…",69,[[]]],[11,"sln_deth_into","","Computes the `(sign, natural_log)` of the determinant of…",69,[[]]],[0,"svd","ndarray_linalg","Singular-value decomposition (SVD)",null,null],[8,"SVD","ndarray_linalg::svd","singular-value decomposition of matrix reference",null,null],[16,"U","","",77,null],[16,"VT","","",77,null],[16,"Sigma","","",77,null],[10,"svd","","",77,[[],["result",6]]],[8,"SVDInto","","singular-value decomposition",null,null],[16,"U","","",78,null],[16,"VT","","",78,null],[16,"Sigma","","",78,null],[10,"svd_into","","",78,[[],["result",6]]],[8,"SVDInplace","","singular-value decomposition for mutable reference of matrix",null,null],[16,"U","","",79,null],[16,"VT","","",79,null],[16,"Sigma","","",79,null],[10,"svd_inplace","","",79,[[],["result",6]]],[0,"svddc","ndarray_linalg","Singular-value decomposition (SVD) by divide-and-conquer…",null,null],[4,"UVTFlag","ndarray_linalg::svddc","Specifies how many of the columns of U and rows of Vᵀ are…",null,null],[13,"Full","","All m columns of U and all n rows of Vᵀ.",80,null],[13,"Some","","The first min(m,n) columns of U and the first min(m,n)…",80,null],[13,"None","","No columns of U or rows of Vᵀ.",80,null],[8,"SVDDC","","Singular-value decomposition of matrix (copying) by…",null,null],[16,"U","","",81,null],[16,"VT","","",81,null],[16,"Sigma","","",81,null],[10,"svddc","","",81,[[["uvtflag",4]],["result",6]]],[8,"SVDDCInto","","Singular-value decomposition of matrix by divide-and-conquer",null,null],[16,"U","","",82,null],[16,"VT","","",82,null],[16,"Sigma","","",82,null],[10,"svddc_into","","",82,[[["uvtflag",4]],["result",6]]],[8,"SVDDCInplace","","Singular-value decomposition of matrix reference by…",null,null],[16,"U","","",83,null],[16,"VT","","",83,null],[16,"Sigma","","",83,null],[10,"svddc_inplace","","",83,[[["uvtflag",4]],["result",6]]],[0,"trace","ndarray_linalg","Trace calculation",null,null],[8,"Trace","ndarray_linalg::trace","",null,null],[16,"Output","","",84,null],[10,"trace","","",84,[[],["result",6]]],[0,"triangular","ndarray_linalg","Methods for triangular matrices",null,null],[4,"Diag","ndarray_linalg::triangular","",null,null],[13,"Unit","","",85,null],[13,"NonUnit","","",85,null],[8,"SolveTriangular","","solve a triangular system with upper triangular matrix",null,null],[10,"solve_triangular","","",86,[[["uplo",4],["diag",4],["arraybase",3]],[["result",6],["array",6]]]],[8,"SolveTriangularInto","","solve a triangular system with upper triangular matrix",null,null],[10,"solve_triangular_into","","",87,[[["uplo",4],["diag",4],["arraybase",3]],[["result",6],["arraybase",3]]]],[8,"SolveTriangularInplace","","solve a triangular system with upper triangular matrix",null,null],[10,"solve_triangular_inplace","","",88,[[["uplo",4],["diag",4],["arraybase",3]],[["arraybase",3],["result",6]]]],[8,"IntoTriangular","","",null,null],[10,"into_triangular","","",89,[[["uplo",4]]]],[0,"tridiagonal","ndarray_linalg","Vectors as a Tridiagonal matrix & Methods for tridiagonal…",null,null],[3,"LUFactorizedTridiagonal","ndarray_linalg::tridiagonal","Represents the LU factorization of a tridiagonal matrix…",null,null],[12,"a","","A tridiagonal matrix which consists of",90,null],[12,"du2","","(n-2) elements of the second super-diagonal of U.",90,null],[12,"ipiv","","The pivot indices that define the permutation matrix `P`.",90,null],[3,"Tridiagonal","","Represents a tridiagonal matrix as 3 one-dimensional…",null,null],[12,"l","","layout of raw matrix",91,null],[12,"dl","","(n-1) sub-diagonal elements of matrix.",91,null],[12,"d","","(n) diagonal elements of matrix.",91,null],[12,"du","","(n-1) super-diagonal elements of matrix.",91,null],[8,"ExtractTridiagonal","","An interface for making a Tridiagonal struct.",null,null],[10,"extract_tridiagonal","","Extract tridiagonal elements and layout of the raw matrix.",92,[[],[["result",6],["tridiagonal",3]]]],[8,"SolveTridiagonal","","",null,null],[10,"solve_tridiagonal","","Solves a system of linear equations `A * x = b` with…",93,[[["arraybase",3]],[["result",6],["array",6]]]],[10,"solve_tridiagonal_into","","Solves a system of linear equations `A * x = b` with…",93,[[["datamut",8],["arraybase",3]],[["result",6],["arraybase",3]]]],[10,"solve_t_tridiagonal","","Solves a system of linear equations `A^T * x = b` with…",93,[[["arraybase",3]],[["result",6],["array",6]]]],[10,"solve_t_tridiagonal_into","","Solves a system of linear equations `A^T * x = b` with…",93,[[["datamut",8],["arraybase",3]],[["result",6],["arraybase",3]]]],[10,"solve_h_tridiagonal","","Solves a system of linear equations `A^H * x = b` with…",93,[[["arraybase",3]],[["result",6],["array",6]]]],[10,"solve_h_tridiagonal_into","","Solves a system of linear equations `A^H * x = b` with…",93,[[["datamut",8],["arraybase",3]],[["result",6],["arraybase",3]]]],[8,"SolveTridiagonalInplace","","",null,null],[10,"solve_tridiagonal_inplace","","Solves a system of linear equations `A * x = b`…",94,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[10,"solve_t_tridiagonal_inplace","","Solves a system of linear equations `A^T * x = b`…",94,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[10,"solve_h_tridiagonal_inplace","","Solves a system of linear equations `A^H * x = b`…",94,[[["arraybase",3]],[["arraybase",3],["result",6]]]],[8,"FactorizeTridiagonal","","An interface for computing LU factorizations of…",null,null],[10,"factorize_tridiagonal","","Computes the LU factorization `A = P*L*U`, where `P` is a…",95,[[],[["result",6],["lufactorizedtridiagonal",3]]]],[8,"FactorizeTridiagonalInto","","An interface for computing LU factorizations of…",null,null],[10,"factorize_tridiagonal_into","","Computes the LU factorization `A = P*L*U`, where `P` is a…",96,[[],[["result",6],["lufactorizedtridiagonal",3]]]],[8,"DeterminantTridiagonal","","An interface for calculating determinants of tridiagonal…",null,null],[10,"det_tridiagonal","","Computes the determinant of the matrix. Unlike `.det()` of…",97,[[],["result",6]]],[8,"ReciprocalConditionNumTridiagonal","","An interface for estimating the reciprocal condition…",null,null],[10,"rcond_tridiagonal","","Estimates the reciprocal of the condition number of the…",98,[[],["result",6]]],[8,"ReciprocalConditionNumTridiagonalInto","","An interface for estimating the reciprocal condition…",null,null],[10,"rcond_tridiagonal_into","","Estimates the reciprocal of the condition number of the…",99,[[],["result",6]]],[0,"types","ndarray_linalg","Basic types and their methods for linear algebra",null,null],[8,"Scalar","ndarray_linalg::types","",null,null],[16,"Real","","",100,null],[16,"Complex","","",100,null],[10,"real","","Create a new real number",100,[[]]],[10,"complex","","Create a new complex number",100,[[]]],[10,"from_real","","",100,[[]]],[10,"add_real","","",100,[[]]],[10,"sub_real","","",100,[[]]],[10,"mul_real","","",100,[[]]],[10,"div_real","","",100,[[]]],[10,"add_complex","","",100,[[]]],[10,"sub_complex","","",100,[[]]],[10,"mul_complex","","",100,[[]]],[10,"div_complex","","",100,[[]]],[10,"pow","","",100,[[]]],[10,"powi","","",100,[[]]],[10,"powf","","",100,[[]]],[10,"powc","","",100,[[]]],[10,"re","","Real part",100,[[]]],[10,"im","","Imaginary part",100,[[]]],[10,"as_c","","As a complex number",100,[[]]],[10,"conj","","Complex conjugate",100,[[]]],[10,"abs","","Absolute value",100,[[]]],[10,"square","","Sqaure of absolute value",100,[[]]],[10,"sqrt","","",100,[[]]],[10,"exp","","",100,[[]]],[10,"ln","","",100,[[]]],[10,"sin","","",100,[[]]],[10,"cos","","",100,[[]]],[10,"tan","","",100,[[]]],[10,"asin","","",100,[[]]],[10,"acos","","",100,[[]]],[10,"atan","","",100,[[]]],[10,"sinh","","",100,[[]]],[10,"cosh","","",100,[[]]],[10,"tanh","","",100,[[]]],[10,"asinh","","",100,[[]]],[10,"acosh","","",100,[[]]],[10,"atanh","","",100,[[]]],[10,"rand","","",100,[[]]],[8,"Lapack","","Trait for primitive types which implements LAPACK…",null,null],[6,"c32","","",null,null],[6,"c64","","",null,null],[14,"assert_rclose","ndarray_linalg","",null,null],[14,"assert_aclose","","",null,null],[14,"assert_close_max","","",null,null],[14,"assert_close_l1","","",null,null],[14,"assert_close_l2","","",null,null],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"into_iter","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",47,[[]]],[11,"into","","",47,[[]]],[11,"borrow","","",47,[[]]],[11,"borrow_mut","","",47,[[]]],[11,"try_from","","",47,[[],["result",4]]],[11,"try_into","","",47,[[],["result",4]]],[11,"type_id","","",47,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","ndarray_linalg::solveh","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","ndarray_linalg::cholesky","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","ndarray_linalg::diagonal","",101,[[]]],[11,"into","","",101,[[]]],[11,"borrow","","",101,[[]]],[11,"borrow_mut","","",101,[[]]],[11,"try_from","","",101,[[],["result",4]]],[11,"try_into","","",101,[[],["result",4]]],[11,"type_id","","",101,[[],["typeid",3]]],[11,"from","ndarray_linalg::error","",26,[[]]],[11,"into","","",26,[[]]],[11,"to_string","","",26,[[],["string",3]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from","ndarray_linalg::krylov","",31,[[]]],[11,"into","","",31,[[]]],[11,"borrow","","",31,[[]]],[11,"borrow_mut","","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"try_into","","",31,[[],["result",4]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"from","","",32,[[]]],[11,"into","","",32,[[]]],[11,"to_owned","","",32,[[]]],[11,"clone_into","","",32,[[]]],[11,"borrow","","",32,[[]]],[11,"borrow_mut","","",32,[[]]],[11,"try_from","","",32,[[],["result",4]]],[11,"try_into","","",32,[[],["result",4]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"from","ndarray_linalg::krylov::arnoldi","",33,[[]]],[11,"into","","",33,[[]]],[11,"into_iter","","",33,[[]]],[11,"borrow","","",33,[[]]],[11,"borrow_mut","","",33,[[]]],[11,"try_from","","",33,[[],["result",4]]],[11,"try_into","","",33,[[],["result",4]]],[11,"type_id","","",33,[[],["typeid",3]]],[11,"from","ndarray_linalg::krylov::householder","",34,[[]]],[11,"into","","",34,[[]]],[11,"to_owned","","",34,[[]]],[11,"clone_into","","",34,[[]]],[11,"borrow","","",34,[[]]],[11,"borrow_mut","","",34,[[]]],[11,"try_from","","",34,[[],["result",4]]],[11,"try_into","","",34,[[],["result",4]]],[11,"type_id","","",34,[[],["typeid",3]]],[11,"from","ndarray_linalg::krylov::mgs","",35,[[]]],[11,"into","","",35,[[]]],[11,"to_owned","","",35,[[]]],[11,"clone_into","","",35,[[]]],[11,"borrow","","",35,[[]]],[11,"borrow_mut","","",35,[[]]],[11,"try_from","","",35,[[],["result",4]]],[11,"try_into","","",35,[[],["result",4]]],[11,"type_id","","",35,[[],["typeid",3]]],[11,"from","ndarray_linalg::layout","",37,[[]]],[11,"into","","",37,[[]]],[11,"to_owned","","",37,[[]]],[11,"clone_into","","",37,[[]]],[11,"borrow","","",37,[[]]],[11,"borrow_mut","","",37,[[]]],[11,"try_from","","",37,[[],["result",4]]],[11,"try_into","","",37,[[],["result",4]]],[11,"type_id","","",37,[[],["typeid",3]]],[11,"from","ndarray_linalg::least_squares","",42,[[]]],[11,"into","","",42,[[]]],[11,"to_owned","","",42,[[]]],[11,"clone_into","","",42,[[]]],[11,"borrow","","",42,[[]]],[11,"borrow_mut","","",42,[[]]],[11,"try_from","","",42,[[],["result",4]]],[11,"try_into","","",42,[[],["result",4]]],[11,"type_id","","",42,[[],["typeid",3]]],[11,"from","ndarray_linalg::lobpcg","",46,[[]]],[11,"into","","",46,[[]]],[11,"borrow","","",46,[[]]],[11,"borrow_mut","","",46,[[]]],[11,"try_from","","",46,[[],["result",4]]],[11,"try_into","","",46,[[],["result",4]]],[11,"type_id","","",46,[[],["typeid",3]]],[11,"from","ndarray_linalg::norm","",48,[[]]],[11,"into","","",48,[[]]],[11,"borrow","","",48,[[]]],[11,"borrow_mut","","",48,[[]]],[11,"try_from","","",48,[[],["result",4]]],[11,"try_into","","",48,[[],["result",4]]],[11,"type_id","","",48,[[],["typeid",3]]],[11,"from","ndarray_linalg::opnorm","",51,[[]]],[11,"into","","",51,[[]]],[11,"to_owned","","",51,[[]]],[11,"clone_into","","",51,[[]]],[11,"borrow","","",51,[[]]],[11,"borrow_mut","","",51,[[]]],[11,"try_from","","",51,[[],["result",4]]],[11,"try_into","","",51,[[],["result",4]]],[11,"type_id","","",51,[[],["typeid",3]]],[11,"from","ndarray_linalg::solve","",58,[[]]],[11,"into","","",58,[[]]],[11,"to_owned","","",58,[[]]],[11,"clone_into","","",58,[[]]],[11,"borrow","","",58,[[]]],[11,"borrow_mut","","",58,[[]]],[11,"try_from","","",58,[[],["result",4]]],[11,"try_into","","",58,[[],["result",4]]],[11,"type_id","","",58,[[],["typeid",3]]],[11,"from","","",59,[[]]],[11,"into","","",59,[[]]],[11,"to_owned","","",59,[[]]],[11,"clone_into","","",59,[[]]],[11,"borrow","","",59,[[]]],[11,"borrow_mut","","",59,[[]]],[11,"try_from","","",59,[[],["result",4]]],[11,"try_into","","",59,[[],["result",4]]],[11,"type_id","","",59,[[],["typeid",3]]],[11,"from","ndarray_linalg::solveh","",69,[[]]],[11,"into","","",69,[[]]],[11,"borrow","","",69,[[]]],[11,"borrow_mut","","",69,[[]]],[11,"try_from","","",69,[[],["result",4]]],[11,"try_into","","",69,[[],["result",4]]],[11,"type_id","","",69,[[],["typeid",3]]],[11,"from","ndarray_linalg::svddc","",80,[[]]],[11,"into","","",80,[[]]],[11,"to_owned","","",80,[[]]],[11,"clone_into","","",80,[[]]],[11,"borrow","","",80,[[]]],[11,"borrow_mut","","",80,[[]]],[11,"try_from","","",80,[[],["result",4]]],[11,"try_into","","",80,[[],["result",4]]],[11,"type_id","","",80,[[],["typeid",3]]],[11,"from","ndarray_linalg::triangular","",85,[[]]],[11,"into","","",85,[[]]],[11,"to_owned","","",85,[[]]],[11,"clone_into","","",85,[[]]],[11,"borrow","","",85,[[]]],[11,"borrow_mut","","",85,[[]]],[11,"try_from","","",85,[[],["result",4]]],[11,"try_into","","",85,[[],["result",4]]],[11,"type_id","","",85,[[],["typeid",3]]],[11,"from","ndarray_linalg::tridiagonal","",90,[[]]],[11,"into","","",90,[[]]],[11,"to_owned","","",90,[[]]],[11,"clone_into","","",90,[[]]],[11,"borrow","","",90,[[]]],[11,"borrow_mut","","",90,[[]]],[11,"try_from","","",90,[[],["result",4]]],[11,"try_into","","",90,[[],["result",4]]],[11,"type_id","","",90,[[],["typeid",3]]],[11,"from","","",91,[[]]],[11,"into","","",91,[[]]],[11,"to_owned","","",91,[[]]],[11,"clone_into","","",91,[[]]],[11,"borrow","","",91,[[]]],[11,"borrow_mut","","",91,[[]]],[11,"try_from","","",91,[[],["result",4]]],[11,"try_into","","",91,[[],["result",4]]],[11,"type_id","","",91,[[],["typeid",3]]],[11,"eq","","",90,[[["lufactorizedtridiagonal",3]]]],[11,"ne","","",90,[[["lufactorizedtridiagonal",3]]]],[11,"eq","","",91,[[["tridiagonal",3]]]],[11,"ne","","",91,[[["tridiagonal",3]]]],[11,"eq","ndarray_linalg::layout","",37,[[["matrixlayout",4]]]],[11,"ne","","",37,[[["matrixlayout",4]]]],[11,"eq","ndarray_linalg::svddc","",80,[[["uvtflag",4]]]],[11,"clone","ndarray_linalg::solve","",58,[[],["transpose",4]]],[11,"clone","ndarray_linalg::triangular","",85,[[],["diag",4]]],[11,"clone","ndarray_linalg::tridiagonal","",91,[[],["tridiagonal",3]]],[11,"clone","","",90,[[],["lufactorizedtridiagonal",3]]],[11,"clone","ndarray_linalg::svddc","",80,[[],["uvtflag",4]]],[11,"clone","ndarray_linalg::layout","",37,[[],["matrixlayout",4]]],[11,"clone","ndarray_linalg::solveh","",2,[[],["uplo",4]]],[11,"clone","ndarray_linalg::opnorm","",51,[[],["normtype",4]]],[11,"index","ndarray_linalg::tridiagonal","",91,[[]]],[11,"index","","",91,[[]]],[11,"fmt","ndarray_linalg::opnorm","",51,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","ndarray_linalg::triangular","",85,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","ndarray_linalg::solve","",58,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","ndarray_linalg::solveh","",2,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","ndarray_linalg::layout","",37,[[["formatter",3]],[["error",3],["result",4]]]],[11,"index_mut","ndarray_linalg::tridiagonal","",91,[[]]],[11,"index_mut","","",91,[[]]],[11,"solvec_inplace","ndarray_linalg::cholesky","",3,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"invc","","",3,[[],["result",6]]],[11,"invc_into","","",3,[[],["result",6]]],[11,"detc","","",3,[[]]],[11,"ln_detc","","",3,[[]]],[11,"detc_into","","",3,[[]]],[11,"ln_detc_into","","",3,[[]]],[11,"dim","ndarray_linalg::krylov::householder","",34,[[]]],[11,"len","","",34,[[]]],[11,"tolerance","","",34,[[]]],[11,"decompose","","",34,[[["arraybase",3]],["array1",6]]],[11,"coeff","","",34,[[["arraybase",3],["ix1",6]],["array1",6]]],[11,"div_append","","",34,[[["arraybase",3]],["appendresult",4]]],[11,"append","","",34,[[["arraybase",3],["ix1",6]],["appendresult",4]]],[11,"get_q","","",34,[[],["q",6]]],[11,"dim","ndarray_linalg::krylov::mgs","",35,[[]]],[11,"len","","",35,[[]]],[11,"tolerance","","",35,[[]]],[11,"decompose","","",35,[[["arraybase",3]],["array1",6]]],[11,"coeff","","",35,[[["arraybase",3],["ix1",6]],["array1",6]]],[11,"append","","",35,[[["arraybase",3],["ix1",6]],["appendresult",4]]],[11,"div_append","","",35,[[["arraybase",3]],["appendresult",4]]],[11,"get_q","","",35,[[],["q",6]]],[11,"apply_mut","ndarray_linalg::diagonal","",101,[[["arraybase",3]]]],[11,"opnorm","ndarray_linalg::tridiagonal","",91,[[["normtype",4]],["result",6]]],[11,"solve_inplace","ndarray_linalg::solve","",59,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_t_inplace","","",59,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_h_inplace","","",59,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"inv","","",59,[[],[["result",6],["array2",6]]]],[11,"inv_into","","",59,[[],[["result",6],["arraybase",3]]]],[11,"sln_det","","",59,[[],["result",6]]],[11,"sln_det_into","","",59,[[],["result",6]]],[11,"rcond","","",59,[[],["result",6]]],[11,"rcond_into","","",59,[[],["result",6]]],[11,"solveh_inplace","ndarray_linalg::solveh","",69,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"invh","","",69,[[],["result",6]]],[11,"invh_into","","",69,[[],[["result",6],["arraybase",3]]]],[11,"solve_tridiagonal","ndarray_linalg::tridiagonal","",90,[[["arraybase",3]],[["array",6],["result",6]]]],[11,"solve_tridiagonal_into","","",90,[[["datamut",8],["arraybase",3],["ix2",6]],[["result",6],["arraybase",3]]]],[11,"solve_t_tridiagonal","","",90,[[["arraybase",3]],[["array",6],["result",6]]]],[11,"solve_t_tridiagonal_into","","",90,[[["datamut",8],["arraybase",3],["ix2",6]],[["result",6],["arraybase",3]]]],[11,"solve_h_tridiagonal","","",90,[[["arraybase",3]],[["array",6],["result",6]]]],[11,"solve_h_tridiagonal_into","","",90,[[["datamut",8],["arraybase",3],["ix2",6]],[["result",6],["arraybase",3]]]],[11,"solve_tridiagonal","","",91,[[["arraybase",3]],[["array",6],["result",6]]]],[11,"solve_tridiagonal_into","","",91,[[["arraybase",3],["datamut",8],["ix2",6]],[["result",6],["arraybase",3]]]],[11,"solve_t_tridiagonal","","",91,[[["arraybase",3]],[["array",6],["result",6]]]],[11,"solve_t_tridiagonal_into","","",91,[[["arraybase",3],["datamut",8],["ix2",6]],[["result",6],["arraybase",3]]]],[11,"solve_h_tridiagonal","","",91,[[["arraybase",3]],[["array",6],["result",6]]]],[11,"solve_h_tridiagonal_into","","",91,[[["arraybase",3],["datamut",8],["ix2",6]],[["result",6],["arraybase",3]]]],[11,"solve_tridiagonal","","",90,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_tridiagonal_into","","",90,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[11,"solve_t_tridiagonal","","",90,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_t_tridiagonal_into","","",90,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[11,"solve_h_tridiagonal","","",90,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_h_tridiagonal_into","","",90,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[11,"solve_tridiagonal","","",91,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_tridiagonal_into","","",91,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[11,"solve_t_tridiagonal","","",91,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_t_tridiagonal_into","","",91,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[11,"solve_h_tridiagonal","","",91,[[["arraybase",3]],[["result",6],["array",6]]]],[11,"solve_h_tridiagonal_into","","",91,[[["datamut",8],["arraybase",3],["ix1",6]],[["result",6],["arraybase",3]]]],[11,"solve_tridiagonal_inplace","","",90,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_t_tridiagonal_inplace","","",90,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_h_tridiagonal_inplace","","",90,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_tridiagonal_inplace","","",91,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_t_tridiagonal_inplace","","",91,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"solve_h_tridiagonal_inplace","","",91,[[["arraybase",3]],[["result",6],["arraybase",3]]]],[11,"factorize_tridiagonal","","",91,[[],[["result",6],["lufactorizedtridiagonal",3]]]],[11,"factorize_tridiagonal_into","","",91,[[],[["result",6],["lufactorizedtridiagonal",3]]]],[11,"det_tridiagonal","","",91,[[],["result",6]]],[11,"rcond_tridiagonal","","",90,[[],["result",6]]],[11,"rcond_tridiagonal_into","","",90,[[],["result",6]]],[11,"from","ndarray_linalg::error","",26,[[["error",4]]]],[11,"from","","",26,[[["shapeerror",3]]]],[11,"into_iter","ndarray_linalg","",0,[[],["truncatedeigiterator",3]]],[11,"next","ndarray_linalg::krylov::arnoldi","",33,[[],["option",4]]],[11,"clone","ndarray_linalg::krylov::householder","",34,[[],["householder",3]]],[11,"clone","ndarray_linalg::krylov::mgs","",35,[[],["mgs",3]]],[11,"clone","ndarray_linalg::krylov","",32,[[],["strategy",4]]],[11,"clone","ndarray_linalg::least_squares","",42,[[],["leastsquaresresult",3]]],[11,"clone","ndarray_linalg","",1,[[],["order",4]]],[11,"clone","ndarray_linalg::solve","",59,[[],["lufactorized",3]]],[11,"eq","ndarray_linalg::krylov","",32,[[["strategy",4]]]],[11,"fmt","ndarray_linalg::error","",26,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::krylov::householder","",34,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::krylov::mgs","",35,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::krylov","",32,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::least_squares","",42,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg","",1,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::lobpcg","",46,[[["formatter",3]],["result",6]]],[11,"fmt","ndarray_linalg::error","",26,[[["formatter",3]],["result",6]]],[11,"source","","",26,[[],[["option",4],["error",8]]]],[11,"t","ndarray_linalg::solveh","",2,[[],["uplo",4]]],[11,"size","ndarray_linalg::layout","",37,[[]]],[11,"resized","","",37,[[],["matrixlayout",4]]],[11,"lda","","",37,[[]]],[11,"len","","",37,[[]]],[11,"is_empty","","",37,[[]]],[11,"same_order","","",37,[[["matrixlayout",4]]]],[11,"toggle_order","","",37,[[],["matrixlayout",4]]],[11,"t","","Transpose without changing memory representation",37,[[],["matrixlayout",4]]],[11,"transpose","ndarray_linalg::opnorm","",51,[[],["normtype",4]]]],"p":[[3,"TruncatedEig"],[4,"TruncatedOrder"],[4,"UPLO"],[3,"CholeskyFactorized"],[8,"Cholesky"],[8,"CholeskyInto"],[8,"CholeskyInplace"],[8,"FactorizeC"],[8,"FactorizeCInto"],[8,"SolveC"],[8,"InverseC"],[8,"InverseCInto"],[8,"DeterminantC"],[8,"DeterminantCInto"],[8,"IntoDiagonal"],[8,"AsDiagonal"],[8,"Eig"],[8,"EigVals"],[8,"Eigh"],[8,"EighInplace"],[8,"EighInto"],[8,"EigValsh"],[8,"EigValshInto"],[8,"EigValshInplace"],[8,"SymmetricSqrt"],[8,"SymmetricSqrtInto"],[4,"LinalgError"],[13,"NotSquare"],[13,"InvalidStride"],[13,"NotStandardShape"],[8,"InnerProduct"],[4,"AppendResult"],[4,"Strategy"],[3,"Arnoldi"],[3,"Householder"],[3,"MGS"],[8,"Orthogonalizer"],[4,"MatrixLayout"],[13,"C"],[13,"F"],[8,"AllocatedArray"],[8,"AllocatedArrayMut"],[3,"LeastSquaresResult"],[8,"LeastSquaresSvd"],[8,"LeastSquaresSvdInto"],[8,"LeastSquaresSvdInPlace"],[4,"LobpcgResult"],[3,"TruncatedSvd"],[4,"NormalizeAxis"],[8,"Norm"],[8,"LinearOperator"],[4,"NormType"],[8,"OperationNorm"],[8,"QR"],[8,"QRInto"],[8,"QRSquare"],[8,"QRSquareInto"],[8,"QRSquareInplace"],[4,"Transpose"],[3,"LUFactorized"],[8,"Solve"],[8,"Factorize"],[8,"FactorizeInto"],[8,"Inverse"],[8,"InverseInto"],[8,"Determinant"],[8,"DeterminantInto"],[8,"ReciprocalConditionNum"],[8,"ReciprocalConditionNumInto"],[3,"BKFactorized"],[8,"SolveH"],[8,"FactorizeH"],[8,"FactorizeHInto"],[8,"InverseH"],[8,"InverseHInto"],[8,"DeterminantH"],[8,"DeterminantHInto"],[8,"SVD"],[8,"SVDInto"],[8,"SVDInplace"],[4,"UVTFlag"],[8,"SVDDC"],[8,"SVDDCInto"],[8,"SVDDCInplace"],[8,"Trace"],[4,"Diag"],[8,"SolveTriangular"],[8,"SolveTriangularInto"],[8,"SolveTriangularInplace"],[8,"IntoTriangular"],[3,"LUFactorizedTridiagonal"],[3,"Tridiagonal"],[8,"ExtractTridiagonal"],[8,"SolveTridiagonal"],[8,"SolveTridiagonalInplace"],[8,"FactorizeTridiagonal"],[8,"FactorizeTridiagonalInto"],[8,"DeterminantTridiagonal"],[8,"ReciprocalConditionNumTridiagonal"],[8,"ReciprocalConditionNumTridiagonalInto"],[8,"Scalar"],[3,"Diagonal"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);